"""
This type stub file was generated by pyright.
"""

from enum import Enum

"""
This is the Django template system.

How it works:

The Lexer.tokenize() method converts a template string (i.e., a string
containing markup with custom template tags) to tokens, which can be either
plain text (TokenType.TEXT), variables (TokenType.VAR), or block statements
(TokenType.BLOCK).

The Parser() class takes a list of tokens in its constructor, and its parse()
method returns a compiled template -- which is, under the hood, a list of
Node objects.

Each Node is responsible for creating some sort of output -- e.g. simple text
(TextNode), variable values in a given context (VariableNode), results of basic
logic (IfNode), results of looping (ForNode), or anything else. The core Node
types are TextNode, VariableNode, IfNode and ForNode, but plugin modules can
define their own custom node types.

Each Node has a render() method, which takes a Context and returns a string of
the rendered node. For example, the render() method of a Variable Node returns
the variable's value as a string. The render() method of a ForNode returns the
rendered output of whatever was inside the loop, recursively.

The Template class is a convenient wrapper that takes care of template
compilation and rendering.

Usage:

The only thing you should ever use directly in this file is the Template class.
Create a compiled template object with a template_string, then call render()
with a context. In the compilation stage, the TemplateSyntaxError exception
will be raised if the template doesn't have proper syntax.

Sample code:

>>> from django import template
>>> s = '<html>{% if test %}<h1>{{ varvalue }}</h1>{% endif %}</html>'
>>> t = template.Template(s)

(t is now a compiled template, and its render() method can be called multiple
times with multiple contexts)

>>> c = template.Context({'test':True, 'varvalue': 'Hello'})
>>> t.render(c)
'<html><h1>Hello</h1></html>'
>>> c = template.Context({'test':False, 'varvalue': 'Hello'})
>>> t.render(c)
'<html></html>'
"""
FILTER_SEPARATOR = ...
FILTER_ARGUMENT_SEPARATOR = ...
VARIABLE_ATTRIBUTE_SEPARATOR = ...
BLOCK_TAG_START = ...
BLOCK_TAG_END = ...
VARIABLE_TAG_START = ...
VARIABLE_TAG_END = ...
COMMENT_TAG_START = ...
COMMENT_TAG_END = ...
SINGLE_BRACE_START = ...
SINGLE_BRACE_END = ...
UNKNOWN_SOURCE = ...
tag_re = ...
logger = ...
class TokenType(Enum):
    TEXT = ...
    VAR = ...
    BLOCK = ...
    COMMENT = ...


class VariableDoesNotExist(Exception):
    def __init__(self, msg, params=...) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    


class Origin:
    def __init__(self, name, template_name=..., loader=...) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    @property
    def loader_name(self): # -> LiteralString | None:
        ...
    


class Template:
    def __init__(self, template_string, origin=..., name=..., engine=...) -> None:
        ...
    
    def __iter__(self): # -> Generator[Unknown, None, None]:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def render(self, context): # -> SafeString:
        "Display stage -- can be called many times"
        ...
    
    def compile_nodelist(self): # -> NodeList:
        """
        Parse and compile the template source into a nodelist. If debug
        is True and an exception occurs during parsing, the exception is
        annotated with contextual line information where it occurred in the
        template source.
        """
        ...
    
    def get_exception_info(self, exception, token): # -> dict[str, Unknown]:
        """
        Return a dictionary containing contextual line information of where
        the exception occurred in the template. The following information is
        provided:

        message
            The message of the exception raised.

        source_lines
            The lines before, after, and including the line the exception
            occurred on.

        line
            The line number the exception occurred on.

        before, during, after
            The line the exception occurred on split into three parts:
            1. The content before the token that raised the error.
            2. The token that raised the error.
            3. The content after the token that raised the error.

        total
            The number of lines in source_lines.

        top
            The line number where source_lines starts.

        bottom
            The line number where source_lines ends.

        start
            The start position of the token in the template source.

        end
            The end position of the token in the template source.
        """
        ...
    


def linebreak_iter(template_source): # -> Generator[Unknown | int, None, None]:
    ...

class Token:
    def __init__(self, token_type, contents, position=..., lineno=...) -> None:
        """
        A token representing a string from the template.

        token_type
            A TokenType, either .TEXT, .VAR, .BLOCK, or .COMMENT.

        contents
            The token source string.

        position
            An optional tuple containing the start and end index of the token
            in the template source. This is used for traceback information
            when debug is on.

        lineno
            The line number the token appears on in the template source.
            This is used for traceback information and gettext files.
        """
        ...
    
    def __repr__(self): # -> LiteralString:
        ...
    
    def split_contents(self): # -> list[Unknown]:
        ...
    


class Lexer:
    def __init__(self, template_string) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def tokenize(self): # -> list[Unknown]:
        """
        Return a list of tokens from a given template_string.
        """
        ...
    
    def create_token(self, token_string, position, lineno, in_tag): # -> Token:
        """
        Convert the given token string into a new Token object and return it.
        If in_tag is True, we are processing something that matched a tag,
        otherwise it should be treated as a literal string.
        """
        ...
    


class DebugLexer(Lexer):
    def tokenize(self): # -> list[Unknown]:
        """
        Split a template string into tokens and annotates each token with its
        start and end position in the source. This is slower than the default
        lexer so only use it when debug is True.
        """
        ...
    


class Parser:
    def __init__(self, tokens, libraries=..., builtins=..., origin=...) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def parse(self, parse_until=...): # -> NodeList:
        """
        Iterate through the parser tokens and compiles each one into a node.

        If parse_until is provided, parsing will stop once one of the
        specified tokens has been reached. This is formatted as a list of
        tokens, e.g. ['elif', 'else', 'endif']. If no matching token is
        reached, raise an exception with the unclosed block tag details.
        """
        ...
    
    def skip_past(self, endtag): # -> None:
        ...
    
    def extend_nodelist(self, nodelist, node, token): # -> None:
        ...
    
    def error(self, token, e): # -> TemplateSyntaxError | Exception:
        """
        Return an exception annotated with the originating token. Since the
        parser can be called recursively, check if a token is already set. This
        ensures the innermost token is highlighted if an exception occurs,
        e.g. a compile error within the body of an if statement.
        """
        ...
    
    def invalid_block_tag(self, token, command, parse_until=...):
        ...
    
    def unclosed_block_tag(self, parse_until):
        ...
    
    def next_token(self):
        ...
    
    def prepend_token(self, token): # -> None:
        ...
    
    def delete_first_token(self): # -> None:
        ...
    
    def add_library(self, lib): # -> None:
        ...
    
    def compile_filter(self, token): # -> FilterExpression:
        """
        Convenient wrapper for FilterExpression
        """
        ...
    
    def find_filter(self, filter_name):
        ...
    


constant_string = ...
constant_string = ...
filter_raw_string = ...
filter_re = ...
class FilterExpression:
    """
    Parse a variable token and its optional filters (all as a single string),
    and return a list of tuples of the filter name and arguments.
    Sample::

        >>> token = 'variable|default:"Default value"|date:"Y-m-d"'
        >>> p = Parser('')
        >>> fe = FilterExpression(token, p)
        >>> len(fe.filters)
        2
        >>> fe.var
        <Variable: 'variable'>
    """
    __slots__ = ...
    def __init__(self, token, parser) -> None:
        ...
    
    def resolve(self, context, ignore_failures=...): # -> __proxy__ | float | int | str | _Wrapped[(...), Unknown, (*args: Unknown, **kwargs: Unknown), Unknown] | SafeString | Variable | None:
        ...
    
    def args_check(name, func, provided): # -> Literal[True]:
        ...
    
    args_check = ...
    def __str__(self) -> str:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class Variable:
    """
    A template variable, resolvable against a given context. The variable may
    be a hard-coded string (if it begins and ends with single or double quote
    marks)::

        >>> c = {'article': {'section':'News'}}
        >>> Variable('article.section').resolve(c)
        'News'
        >>> Variable('article').resolve(c)
        {'section': 'News'}
        >>> class AClass: pass
        >>> c = AClass()
        >>> c.article = AClass()
        >>> c.article.section = 'News'

    (The example assumes VARIABLE_ATTRIBUTE_SEPARATOR is '.')
    """
    __slots__ = ...
    def __init__(self, var) -> None:
        ...
    
    def resolve(self, context): # -> __proxy__ | float | int | str | _Wrapped[(...), Unknown, (*args: Unknown, **kwargs: Unknown), Unknown] | SafeString | None:
        """Resolve this variable against a given context."""
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __str__(self) -> str:
        ...
    


class Node:
    must_be_first = ...
    child_nodelists = ...
    token = ...
    def render(self, context): # -> None:
        """
        Return the node rendered as a string.
        """
        ...
    
    def render_annotated(self, context): # -> None:
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        ...
    
    def get_nodes_by_type(self, nodetype): # -> list[Unknown]:
        """
        Return a list of all nodes (within this node and its nodelist)
        of the given type
        """
        ...
    


class NodeList(list):
    contains_nontext = ...
    def render(self, context): # -> SafeString:
        ...
    
    def get_nodes_by_type(self, nodetype): # -> list[Unknown]:
        "Return a list of all nodes of the given type"
        ...
    


class TextNode(Node):
    child_nodelists = ...
    def __init__(self, s) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def render(self, context): # -> Unknown:
        ...
    
    def render_annotated(self, context): # -> Unknown:
        """
        Return the given value.

        The default implementation of this method handles exceptions raised
        during rendering, which is not necessary for text nodes.
        """
        ...
    


def render_value_in_context(value, context): # -> SafeString | str:
    """
    Convert any value to a string to become part of a rendered template. This
    means escaping, if required, and conversion to a string. If value is a
    string, it's expected to already be translated.
    """
    ...

class VariableNode(Node):
    child_nodelists = ...
    def __init__(self, filter_expression) -> None:
        ...
    
    def __repr__(self): # -> LiteralString:
        ...
    
    def render(self, context): # -> SafeString | str:
        ...
    


kwarg_re = ...
def token_kwargs(bits, parser, support_legacy=...): # -> dict[Unknown, Unknown]:
    """
    Parse token keyword arguments and return a dictionary of the arguments
    retrieved from the ``bits`` token list.

    `bits` is a list containing the remainder of the token (split by spaces)
    that is to be checked for arguments. Valid arguments are removed from this
    list.

    `support_legacy` - if True, the legacy format ``1 as foo`` is accepted.
    Otherwise, only the standard ``foo=1`` format is allowed.

    There is no requirement for all remaining token ``bits`` to be keyword
    arguments, so return the dictionary as soon as an invalid argument format
    is reached.
    """
    ...

