"""
This type stub file was generated by pyright.
"""

from contextlib import contextmanager

_builtin_context_processors = ...
class ContextPopException(Exception):
    "pop() has been called more times than push()"
    ...


class ContextDict(dict):
    def __init__(self, context, *args, **kwargs) -> None:
        ...
    
    def __enter__(self): # -> Self@ContextDict:
        ...
    
    def __exit__(self, *args, **kwargs): # -> None:
        ...
    


class BaseContext:
    def __init__(self, dict_=...) -> None:
        ...
    
    def __copy__(self): # -> object:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __iter__(self): # -> reversed[dict[str, Unknown]]:
        ...
    
    def push(self, *args, **kwargs): # -> ContextDict:
        ...
    
    def pop(self): # -> dict[str, Unknown]:
        ...
    
    def __setitem__(self, key, value): # -> None:
        "Set a variable in the current context"
        ...
    
    def set_upward(self, key, value): # -> None:
        """
        Set a variable in one of the higher contexts if it exists there,
        otherwise in the current context.
        """
        ...
    
    def __getitem__(self, key):
        "Get a variable's value, starting at the current context and going upward"
        ...
    
    def __delitem__(self, key): # -> None:
        "Delete a variable from the current context"
        ...
    
    def __contains__(self, key): # -> bool:
        ...
    
    def get(self, key, otherwise=...): # -> None:
        ...
    
    def setdefault(self, key, default=...): # -> None:
        ...
    
    def new(self, values=...): # -> Self@BaseContext:
        """
        Return a new context with the same properties, but with only the
        values given in 'values' stored.
        """
        ...
    
    def flatten(self): # -> dict[Unknown, Unknown]:
        """
        Return self.dicts as one dictionary.
        """
        ...
    
    def __eq__(self, other) -> bool:
        """
        Compare two contexts by comparing theirs 'dicts' attributes.
        """
        ...
    


class Context(BaseContext):
    "A stack container for variable context"
    def __init__(self, dict_=..., autoescape=..., use_l10n=..., use_tz=...) -> None:
        ...
    
    @contextmanager
    def bind_template(self, template): # -> Generator[None, None, None]:
        ...
    
    def __copy__(self): # -> object:
        ...
    
    def update(self, other_dict): # -> ContextDict:
        "Push other_dict to the stack of dictionaries in the Context"
        ...
    


class RenderContext(BaseContext):
    """
    A stack container for storing Template state.

    RenderContext simplifies the implementation of template Nodes by providing a
    safe place to store state between invocations of a node's `render` method.

    The RenderContext also provides scoping rules that are more sensible for
    'template local' variables. The render context stack is pushed before each
    template is rendered, creating a fresh scope with nothing in it. Name
    resolution fails if a variable is not found at the top of the RequestContext
    stack. Thus, variables are local to a specific template and don't affect the
    rendering of other templates as they would if they were stored in the normal
    template context.
    """
    template = ...
    def __iter__(self): # -> Generator[str, None, None]:
        ...
    
    def __contains__(self, key): # -> bool:
        ...
    
    def get(self, key, otherwise=...): # -> None:
        ...
    
    def __getitem__(self, key):
        ...
    
    @contextmanager
    def push_state(self, template, isolated_context=...): # -> Generator[None, None, None]:
        ...
    


class RequestContext(Context):
    """
    This subclass of template.Context automatically populates itself using
    the processors defined in the engine's configuration.
    Additional processors can be specified as a list of callables
    using the "processors" keyword argument.
    """
    def __init__(self, request, dict_=..., processors=..., use_l10n=..., use_tz=..., autoescape=...) -> None:
        ...
    
    @contextmanager
    def bind_template(self, template): # -> Generator[None, None, None]:
        ...
    
    def new(self, values=...): # -> Self@RequestContext:
        ...
    


def make_context(context, request=..., **kwargs): # -> Context | RequestContext:
    """
    Create a suitable Context from a plain dict and optionally an HttpRequest.
    """
    ...

