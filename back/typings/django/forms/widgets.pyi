"""
This type stub file was generated by pyright.
"""

from django.utils.html import html_safe

"""
HTML Widget classes
"""
__all__ = ("Media", "MediaDefiningClass", "Widget", "TextInput", "NumberInput", "EmailInput", "URLInput", "PasswordInput", "HiddenInput", "MultipleHiddenInput", "FileInput", "ClearableFileInput", "Textarea", "DateInput", "DateTimeInput", "TimeInput", "CheckboxInput", "Select", "NullBooleanSelect", "SelectMultiple", "RadioSelect", "CheckboxSelectMultiple", "MultiWidget", "SplitDateTimeWidget", "SplitHiddenDateTimeWidget", "SelectDateWidget")
MEDIA_TYPES = ...
class MediaOrderConflictWarning(RuntimeWarning):
    ...


@html_safe
class Media:
    def __init__(self, media=..., css=..., js=...) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __str__(self) -> str:
        ...
    
    def render(self): # -> LiteralString | _Wrapped[(...), Unknown, (*args: Unknown, **kwargs: Unknown), Unknown] | SafeString:
        ...
    
    def render_js(self): # -> list[Unknown | Any | _Wrapped[(...), Unknown, (*args: Unknown, **kwargs: Unknown), Unknown] | SafeString]:
        ...
    
    def render_css(self): # -> chain[Unknown | Any | _Wrapped[(...), Unknown, (*args: Unknown, **kwargs: Unknown), Unknown] | SafeString]:
        ...
    
    def absolute_path(self, path): # -> Any | str:
        """
        Given a relative or absolute path to a static asset, return an absolute
        path. An absolute path will be returned unchanged while a relative path
        will be passed to django.templatetags.static.static().
        """
        ...
    
    def __getitem__(self, name): # -> Media:
        """Return a Media object that only contains media of the given type."""
        ...
    
    @staticmethod
    def merge(*lists): # -> list[Unknown] | list[Any]:
        """
        Merge lists while trying to keep the relative order of the elements.
        Warn if the lists have the same elements in a different relative order.

        For static assets it can be important to have them included in the DOM
        in a certain order. In JavaScript you may not be able to reference a
        global or in CSS you might want to override a style.
        """
        ...
    
    def __add__(self, other): # -> Media:
        ...
    


def media_property(cls): # -> property:
    ...

class MediaDefiningClass(type):
    """
    Metaclass for classes that can have media definitions.
    """
    def __new__(mcs, name, bases, attrs): # -> Self@MediaDefiningClass:
        ...
    


class Widget(metaclass=MediaDefiningClass):
    needs_multipart_form = ...
    is_localized = ...
    is_required = ...
    supports_microseconds = ...
    use_fieldset = ...
    def __init__(self, attrs=...) -> None:
        ...
    
    def __deepcopy__(self, memo): # -> Self@Widget:
        ...
    
    @property
    def is_hidden(self): # -> Literal[False]:
        ...
    
    def subwidgets(self, name, value, attrs=...): # -> Generator[dict[str, Unknown], None, None]:
        ...
    
    def format_value(self, value): # -> str | None:
        """
        Return a value as it should appear when rendered in a template.
        """
        ...
    
    def get_context(self, name, value, attrs): # -> dict[str, dict[str, Unknown]]:
        ...
    
    def render(self, name, value, attrs=..., renderer=...): # -> Any | _Wrapped[(...), Unknown, (*args: Unknown, **kwargs: Unknown), Unknown] | SafeString:
        """Render the widget as an HTML string."""
        ...
    
    def build_attrs(self, base_attrs, extra_attrs=...): # -> dict[Any, Any]:
        """Build an attribute dictionary."""
        ...
    
    def value_from_datadict(self, data, files, name):
        """
        Given a dictionary of data and this widget's name, return the value
        of this widget or None if it's not provided.
        """
        ...
    
    def value_omitted_from_data(self, data, files, name): # -> bool:
        ...
    
    def id_for_label(self, id_):
        """
        Return the HTML ID attribute of this Widget for use by a <label>, given
        the ID of the field. Return an empty string if no ID is available.

        This hook is necessary because some widgets have multiple HTML
        elements and, thus, multiple IDs. In that case, this method should
        return an ID value that corresponds to the first ID in the widget's
        tags.
        """
        ...
    
    def use_required_attribute(self, initial): # -> bool:
        ...
    


class Input(Widget):
    """
    Base class for all <input> widgets.
    """
    input_type = ...
    template_name = ...
    def __init__(self, attrs=...) -> None:
        ...
    
    def get_context(self, name, value, attrs): # -> dict[str, dict[str, Unknown]]:
        ...
    


class TextInput(Input):
    input_type = ...
    template_name = ...


class NumberInput(Input):
    input_type = ...
    template_name = ...


class EmailInput(Input):
    input_type = ...
    template_name = ...


class URLInput(Input):
    input_type = ...
    template_name = ...


class PasswordInput(Input):
    input_type = ...
    template_name = ...
    def __init__(self, attrs=..., render_value=...) -> None:
        ...
    
    def get_context(self, name, value, attrs): # -> dict[str, dict[str, Unknown]]:
        ...
    


class HiddenInput(Input):
    input_type = ...
    template_name = ...


class MultipleHiddenInput(HiddenInput):
    """
    Handle <input type="hidden"> for fields that have a list
    of values.
    """
    template_name = ...
    def get_context(self, name, value, attrs): # -> dict[str, dict[str, Unknown]]:
        ...
    
    def value_from_datadict(self, data, files, name):
        ...
    
    def format_value(self, value): # -> list[Unknown]:
        ...
    


class FileInput(Input):
    input_type = ...
    needs_multipart_form = ...
    template_name = ...
    def format_value(self, value): # -> None:
        """File input never renders a value."""
        ...
    
    def value_from_datadict(self, data, files, name):
        "File widgets take data from FILES, not POST"
        ...
    
    def value_omitted_from_data(self, data, files, name): # -> bool:
        ...
    
    def use_required_attribute(self, initial): # -> bool:
        ...
    


FILE_INPUT_CONTRADICTION = ...
class ClearableFileInput(FileInput):
    clear_checkbox_label = ...
    initial_text = ...
    input_text = ...
    template_name = ...
    def clear_checkbox_name(self, name):
        """
        Given the name of the file input, return the name of the clear checkbox
        input.
        """
        ...
    
    def clear_checkbox_id(self, name):
        """
        Given the name of the clear checkbox input, return the HTML id for it.
        """
        ...
    
    def is_initial(self, value): # -> bool:
        """
        Return whether value is considered to be initial value.
        """
        ...
    
    def format_value(self, value): # -> None:
        """
        Return the file object if it has a defined url attribute.
        """
        ...
    
    def get_context(self, name, value, attrs): # -> dict[str, dict[str, Unknown]]:
        ...
    
    def value_from_datadict(self, data, files, name): # -> object | Literal[False]:
        ...
    
    def value_omitted_from_data(self, data, files, name): # -> bool:
        ...
    


class Textarea(Widget):
    template_name = ...
    def __init__(self, attrs=...) -> None:
        ...
    


class DateTimeBaseInput(TextInput):
    format_key = ...
    supports_microseconds = ...
    def __init__(self, attrs=..., format=...) -> None:
        ...
    
    def format_value(self, value): # -> str:
        ...
    


class DateInput(DateTimeBaseInput):
    format_key = ...
    template_name = ...


class DateTimeInput(DateTimeBaseInput):
    format_key = ...
    template_name = ...


class TimeInput(DateTimeBaseInput):
    format_key = ...
    template_name = ...


def boolean_check(v): # -> bool:
    ...

class CheckboxInput(Input):
    input_type = ...
    template_name = ...
    def __init__(self, attrs=..., check_test=...) -> None:
        ...
    
    def format_value(self, value): # -> str | None:
        """Only return the 'value' attribute if value isn't empty."""
        ...
    
    def get_context(self, name, value, attrs): # -> dict[str, dict[str, Unknown]]:
        ...
    
    def value_from_datadict(self, data, files, name): # -> bool:
        ...
    
    def value_omitted_from_data(self, data, files, name): # -> Literal[False]:
        ...
    


class ChoiceWidget(Widget):
    allow_multiple_selected = ...
    input_type = ...
    template_name = ...
    option_template_name = ...
    add_id_index = ...
    checked_attribute = ...
    option_inherits_attrs = ...
    def __init__(self, attrs=..., choices=...) -> None:
        ...
    
    def __deepcopy__(self, memo): # -> Self@ChoiceWidget:
        ...
    
    def subwidgets(self, name, value, attrs=...): # -> Generator[Unknown, None, None]:
        """
        Yield all "subwidgets" of this widget. Used to enable iterating
        options from a BoundField for choice widgets.
        """
        ...
    
    def options(self, name, value, attrs=...): # -> Generator[Unknown, None, None]:
        """Yield a flat list of options for this widget."""
        ...
    
    def optgroups(self, name, value, attrs=...): # -> list[Unknown]:
        """Return a list of optgroups for this widget."""
        ...
    
    def create_option(self, name, value, label, selected, index, subindex=..., attrs=...): # -> dict[str, Unknown]:
        ...
    
    def get_context(self, name, value, attrs): # -> dict[str, dict[str, Unknown]]:
        ...
    
    def id_for_label(self, id_, index=...): # -> str:
        """
        Use an incremented id for each option where the main widget
        references the zero index.
        """
        ...
    
    def value_from_datadict(self, data, files, name):
        ...
    
    def format_value(self, value): # -> list[Unknown] | list[str]:
        """Return selected values as a list."""
        ...
    


class Select(ChoiceWidget):
    input_type = ...
    template_name = ...
    option_template_name = ...
    add_id_index = ...
    checked_attribute = ...
    option_inherits_attrs = ...
    def get_context(self, name, value, attrs): # -> dict[str, dict[str, Unknown]]:
        ...
    
    def use_required_attribute(self, initial): # -> bool:
        """
        Don't render 'required' if the first <option> has a value, as that's
        invalid HTML.
        """
        ...
    


class NullBooleanSelect(Select):
    """
    A Select Widget intended to be used with NullBooleanField.
    """
    def __init__(self, attrs=...) -> None:
        ...
    
    def format_value(self, value): # -> str:
        ...
    
    def value_from_datadict(self, data, files, name): # -> bool | None:
        ...
    


class SelectMultiple(Select):
    allow_multiple_selected = ...
    def value_from_datadict(self, data, files, name):
        ...
    
    def value_omitted_from_data(self, data, files, name): # -> Literal[False]:
        ...
    


class RadioSelect(ChoiceWidget):
    input_type = ...
    template_name = ...
    option_template_name = ...
    use_fieldset = ...
    def id_for_label(self, id_, index=...): # -> str:
        """
        Don't include for="field_0" in <label> to improve accessibility when
        using a screen reader, in addition clicking such a label would toggle
        the first input.
        """
        ...
    


class CheckboxSelectMultiple(RadioSelect):
    allow_multiple_selected = ...
    input_type = ...
    template_name = ...
    option_template_name = ...
    def use_required_attribute(self, initial): # -> Literal[False]:
        ...
    
    def value_omitted_from_data(self, data, files, name): # -> Literal[False]:
        ...
    


class MultiWidget(Widget):
    """
    A widget that is composed of multiple widgets.

    In addition to the values added by Widget.get_context(), this widget
    adds a list of subwidgets to the context as widget['subwidgets'].
    These can be looped over and rendered like normal widgets.

    You'll probably want to use this class with MultiValueField.
    """
    template_name = ...
    use_fieldset = ...
    def __init__(self, widgets, attrs=...) -> None:
        ...
    
    @property
    def is_hidden(self): # -> bool:
        ...
    
    def get_context(self, name, value, attrs): # -> dict[str, dict[str, Unknown]]:
        ...
    
    def id_for_label(self, id_): # -> Literal['']:
        ...
    
    def value_from_datadict(self, data, files, name): # -> list[Any | Unknown]:
        ...
    
    def value_omitted_from_data(self, data, files, name): # -> bool:
        ...
    
    def decompress(self, value):
        """
        Return a list of decompressed values for the given compressed value.
        The given value can be assumed to be valid, but not necessarily
        non-empty.
        """
        ...
    
    media = ...
    def __deepcopy__(self, memo): # -> Self@MultiWidget:
        ...
    
    @property
    def needs_multipart_form(self): # -> bool:
        ...
    


class SplitDateTimeWidget(MultiWidget):
    """
    A widget that splits datetime input into two <input type="text"> boxes.
    """
    supports_microseconds = ...
    template_name = ...
    def __init__(self, attrs=..., date_format=..., time_format=..., date_attrs=..., time_attrs=...) -> None:
        ...
    
    def decompress(self, value): # -> list[Unknown] | list[None]:
        ...
    


class SplitHiddenDateTimeWidget(SplitDateTimeWidget):
    """
    A widget that splits datetime input into two <input type="hidden"> inputs.
    """
    template_name = ...
    def __init__(self, attrs=..., date_format=..., time_format=..., date_attrs=..., time_attrs=...) -> None:
        ...
    


class SelectDateWidget(Widget):
    """
    A widget that splits date input into three <select> boxes.

    This also serves as an example of a Widget that has more than one HTML
    element and hence implements value_from_datadict.
    """
    none_value = ...
    month_field = ...
    day_field = ...
    year_field = ...
    template_name = ...
    input_type = ...
    select_widget = Select
    date_re = ...
    use_fieldset = ...
    def __init__(self, attrs=..., years=..., months=..., empty_label=...) -> None:
        ...
    
    def get_context(self, name, value, attrs): # -> dict[str, dict[str, Unknown]]:
        ...
    
    def format_value(self, value): # -> dict[str, int | str | None]:
        """
        Return a dict containing the year, month, and day of the current value.
        Use dict instead of a datetime to allow invalid dates such as February
        31 to display correctly.
        """
        ...
    
    def id_for_label(self, id_): # -> LiteralString:
        ...
    
    def value_from_datadict(self, data, files, name): # -> str | None:
        ...
    
    def value_omitted_from_data(self, data, files, name): # -> bool:
        ...
    


