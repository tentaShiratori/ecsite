"""
This type stub file was generated by pyright.
"""

from django.forms.utils import RenderableFormMixin
from django.forms.widgets import MediaDefiningClass
from django.utils.functional import cached_property

"""
Form classes
"""
__all__ = ("BaseForm", "Form")
class DeclarativeFieldsMetaclass(MediaDefiningClass):
    """Collect Fields declared on the base classes."""
    def __new__(mcs, name, bases, attrs): # -> Self@DeclarativeFieldsMetaclass:
        ...
    


class BaseForm(RenderableFormMixin):
    """
    The main implementation of all the Form logic. Note that this class is
    different than Form. See the comments by the Form class for more info. Any
    improvements to the form API should be made to this class, not to the Form
    class.
    """
    default_renderer = ...
    field_order = ...
    prefix = ...
    use_required_attribute = ...
    template_name_div = ...
    template_name_p = ...
    template_name_table = ...
    template_name_ul = ...
    template_name_label = ...
    def __init__(self, data=..., files=..., auto_id=..., prefix=..., initial=..., error_class=..., label_suffix=..., empty_permitted=..., field_order=..., use_required_attribute=..., renderer=...) -> None:
        ...
    
    def order_fields(self, field_order): # -> None:
        """
        Rearrange the fields according to field_order.

        field_order is a list of field names specifying the order. Append fields
        not included in the list in the default order for backward compatibility
        with subclasses not overriding field_order. If field_order is None,
        keep all fields in the order defined in the class. Ignore unknown
        fields in field_order to allow disabling fields in form subclasses
        without redefining ordering.
        """
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __iter__(self): # -> Generator[Unknown, None, None]:
        """Yield the form's fields as BoundField objects."""
        ...
    
    def __getitem__(self, name):
        """Return a BoundField with the given name."""
        ...
    
    @property
    def errors(self): # -> ErrorDict | None:
        """Return an ErrorDict for the data provided for the form."""
        ...
    
    def is_valid(self): # -> bool:
        """Return True if the form has no errors, or False otherwise."""
        ...
    
    def add_prefix(self, field_name): # -> LiteralString:
        """
        Return the field name with a prefix appended, if this Form has a
        prefix set.

        Subclasses may wish to override.
        """
        ...
    
    def add_initial_prefix(self, field_name): # -> LiteralString:
        """Add an 'initial' prefix for checking dynamic initial values."""
        ...
    
    @property
    def template_name(self): # -> Any:
        ...
    
    def get_context(self): # -> dict[str, Unknown]:
        ...
    
    def non_field_errors(self): # -> ErrorList:
        """
        Return an ErrorList of errors that aren't associated with a particular
        field -- i.e., from Form.clean(). Return an empty ErrorList if there
        are none.
        """
        ...
    
    def add_error(self, field, error): # -> None:
        """
        Update the content of `self._errors`.

        The `field` argument is the name of the field to which the errors
        should be added. If it's None, treat the errors as NON_FIELD_ERRORS.

        The `error` argument can be a single error, a list of errors, or a
        dictionary that maps field names to lists of errors. An "error" can be
        either a simple string or an instance of ValidationError with its
        message attribute set and a "list or dictionary" can be an actual
        `list` or `dict` or an instance of ValidationError with its
        `error_list` or `error_dict` attribute set.

        If `error` is a dictionary, the `field` argument *must* be None and
        errors will be added to the fields that correspond to the keys of the
        dictionary.
        """
        ...
    
    def has_error(self, field, code=...): # -> bool:
        ...
    
    def full_clean(self): # -> None:
        """
        Clean all of self.data and populate self._errors and self.cleaned_data.
        """
        ...
    
    def clean(self): # -> dict[Unknown, Unknown]:
        """
        Hook for doing any extra form-wide cleaning after Field.clean() has been
        called on every field. Any ValidationError raised by this method will
        not be associated with a particular field; it will have a special-case
        association with the field named '__all__'.
        """
        ...
    
    def has_changed(self): # -> bool:
        """Return True if data differs from initial."""
        ...
    
    @cached_property
    def changed_data(self): # -> list[Unknown]:
        ...
    
    @property
    def media(self): # -> Media:
        """Return all media required to render the widgets on this form."""
        ...
    
    def is_multipart(self): # -> bool:
        """
        Return True if the form needs to be multipart-encoded, i.e. it has
        FileInput, or False otherwise.
        """
        ...
    
    def hidden_fields(self): # -> list[Unknown]:
        """
        Return a list of all the BoundField objects that are hidden fields.
        Useful for manual form layout in templates.
        """
        ...
    
    def visible_fields(self): # -> list[Unknown]:
        """
        Return a list of BoundField objects that aren't hidden fields.
        The opposite of the hidden_fields() method.
        """
        ...
    
    def get_initial_for_field(self, field, field_name): # -> datetime | time | Any:
        """
        Return initial data for field on form. Use initial data from the form
        or the field, in that order. Evaluate callable values.
        """
        ...
    


class Form(BaseForm, metaclass=DeclarativeFieldsMetaclass):
    "A collection of Fields, plus their associated data."
    ...


