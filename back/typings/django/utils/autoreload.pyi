"""
This type stub file was generated by pyright.
"""

import functools
from django.utils.functional import cached_property

autoreload_started = ...
file_changed = ...
DJANGO_AUTORELOAD_ENV = ...
logger = ...
_error_files = ...
_exception = ...
def is_django_module(module):
    """Return True if the given module is nested under Django."""
    ...

def is_django_path(path): # -> bool:
    """Return True if the given file path is nested under Django."""
    ...

def check_errors(fn): # -> _Wrapped[(...), Unknown, (*args: Unknown, **kwargs: Unknown), None]:
    ...

def raise_last_exception(): # -> None:
    ...

def ensure_echo_on(): # -> None:
    """
    Ensure that echo mode is enabled. Some tools such as PDB disable
    it which causes usability issues after reload.
    """
    ...

def iter_all_python_module_files(): # -> frozenset[Unknown]:
    ...

@functools.lru_cache(maxsize=1)
def iter_modules_and_files(modules, extra_files): # -> frozenset[Unknown]:
    """Iterate through all modules needed to be watched."""
    ...

@functools.lru_cache(maxsize=1)
def common_roots(paths): # -> tuple[Unknown | Path, ...]:
    """
    Return a tuple of common roots that are shared between the given paths.
    File system watchers operate on directories and aren't cheap to create.
    Try to find the minimum set of directories to watch that encompass all of
    the files that need to be watched.
    """
    ...

def sys_path_directories(): # -> Generator[Path, None, None]:
    """
    Yield absolute directories from sys.path, ignoring entries that don't
    exist.
    """
    ...

def get_child_arguments(): # -> list[Unknown] | list[str]:
    """
    Return the executable. This contains a workaround for Windows if the
    executable is reported to not have the .exe extension which can cause bugs
    on reloading.
    """
    ...

def trigger_reload(filename):
    ...

def restart_with_reloader(): # -> int:
    ...

class BaseReloader:
    def __init__(self) -> None:
        ...
    
    def watch_dir(self, path, glob): # -> None:
        ...
    
    def watched_files(self, include_globs=...): # -> Generator[Unknown, None, None]:
        """
        Yield all files that need to be watched, including module files and
        files within globs.
        """
        ...
    
    def wait_for_apps_ready(self, app_reg, django_main_thread): # -> bool:
        """
        Wait until Django reports that the apps have been loaded. If the given
        thread has terminated before the apps are ready, then a SyntaxError or
        other non-recoverable error has been raised. In that case, stop waiting
        for the apps_ready event and continue processing.

        Return True if the thread is alive and the ready event has been
        triggered, or False if the thread is terminated while waiting for the
        event.
        """
        ...
    
    def run(self, django_main_thread): # -> None:
        ...
    
    def run_loop(self): # -> None:
        ...
    
    def tick(self):
        """
        This generator is called in a loop from run_loop. It's important that
        the method takes care of pausing or otherwise waiting for a period of
        time. This split between run_loop() and tick() is to improve the
        testability of the reloader implementations by decoupling the work they
        do from the loop.
        """
        ...
    
    @classmethod
    def check_availability(cls):
        ...
    
    def notify_file_changed(self, path): # -> None:
        ...
    
    @property
    def should_stop(self): # -> bool:
        ...
    
    def stop(self): # -> None:
        ...
    


class StatReloader(BaseReloader):
    SLEEP_TIME = ...
    def tick(self): # -> Generator[None, None, None]:
        ...
    
    def snapshot_files(self): # -> Generator[tuple[Unknown, Unknown], None, None]:
        ...
    
    @classmethod
    def check_availability(cls): # -> Literal[True]:
        ...
    


class WatchmanUnavailable(RuntimeError):
    ...


class WatchmanReloader(BaseReloader):
    def __init__(self) -> None:
        ...
    
    @cached_property
    def client(self):
        ...
    
    def watched_roots(self, watched_files): # -> frozenset[Unknown | Path]:
        ...
    
    def update_watches(self): # -> None:
        ...
    
    def request_processed(self, **kwargs): # -> None:
        ...
    
    def tick(self): # -> Generator[None, None, None]:
        ...
    
    def stop(self): # -> None:
        ...
    
    def check_server_status(self, inner_ex=...): # -> Literal[True]:
        """Return True if the server is available."""
        ...
    
    @classmethod
    def check_availability(cls): # -> None:
        ...
    


def get_reloader(): # -> StatReloader | WatchmanReloader:
    """Return the most suitable reloader for this environment."""
    ...

def start_django(reloader, main_func, *args, **kwargs): # -> None:
    ...

def run_with_reloader(main_func, *args, **kwargs): # -> None:
    ...

