"""
This type stub file was generated by pyright.
"""

from html.parser import HTMLParser
from django.utils.functional import keep_lazy, keep_lazy_text
from django.utils.safestring import SafeString

"""HTML utilities suitable for global use."""
@keep_lazy(SafeString)
def escape(text): # -> SafeString:
    """
    Return the given text with ampersands, quotes and angle brackets encoded
    for use in HTML.

    Always escape input, even if it's already escaped and marked as such.
    This may result in double-escaping. If this is a concern, use
    conditional_escape() instead.
    """
    ...

_js_escapes = ...
@keep_lazy(SafeString)
def escapejs(value): # -> str | _Wrapped[(...), Unknown, (*args: Unknown, **kwargs: Unknown), Unknown] | SafeString:
    """Hex encode characters for use in JavaScript strings."""
    ...

_json_script_escapes = ...
def json_script(value, element_id=...): # -> _Wrapped[(...), Unknown, (*args: Unknown, **kwargs: Unknown), Unknown] | SafeString:
    """
    Escape all the HTML/XML special characters with their unicode escapes, so
    value is safe to be output anywhere except for inside a tag attribute. Wrap
    the escaped JSON in a script tag.
    """
    ...

def conditional_escape(text): # -> SafeString:
    """
    Similar to escape(), except that it doesn't operate on pre-escaped strings.

    This function relies on the __html__ convention used both by Django's
    SafeData class and by third-party libraries like markupsafe.
    """
    ...

def format_html(format_string, *args, **kwargs): # -> _Wrapped[(...), Unknown, (*args: Unknown, **kwargs: Unknown), Unknown] | SafeString:
    """
    Similar to str.format, but pass all arguments through conditional_escape(),
    and call mark_safe() on the result. This function should be used instead
    of str.format or % interpolation to build up small HTML fragments.
    """
    ...

def format_html_join(sep, format_string, args_generator): # -> str | _Wrapped[(...), Unknown, (*args: Unknown, **kwargs: Unknown), Unknown] | SafeString:
    """
    A wrapper of format_html, for the common case of a group of arguments that
    need to be formatted using the same format string, and then joined using
    'sep'. 'sep' is also passed through conditional_escape.

    'args_generator' should be an iterator that returns the sequence of 'args'
    that will be passed to format_html.

    Example:

      format_html_join('\n', "<li>{} {}</li>", ((u.first_name, u.last_name)
                                                  for u in users))
    """
    ...

@keep_lazy_text
def linebreaks(value, autoescape=...): # -> str:
    """Convert newlines into <p> and <br>s."""
    ...

class MLStripper(HTMLParser):
    def __init__(self) -> None:
        ...
    
    def handle_data(self, d): # -> None:
        ...
    
    def handle_entityref(self, name): # -> None:
        ...
    
    def handle_charref(self, name): # -> None:
        ...
    
    def get_data(self): # -> LiteralString:
        ...
    


@keep_lazy_text
def strip_tags(value): # -> str | LiteralString:
    """Return the given HTML with all tags stripped."""
    ...

@keep_lazy_text
def strip_spaces_between_tags(value): # -> str:
    """Return the given HTML with spaces between tags removed."""
    ...

def smart_urlquote(url): # -> str:
    """Quote a URL if it isn't already quoted."""
    ...

class Urlizer:
    """
    Convert any URLs in text into clickable links.

    Work on http://, https://, www. links, and also on links ending in one of
    the original seven gTLDs (.com, .edu, .gov, .int, .mil, .net, and .org).
    Links can have trailing punctuation (periods, commas, close-parens) and
    leading punctuation (opening parens) and it'll still do the right thing.
    """
    trailing_punctuation_chars = ...
    wrapping_punctuation = ...
    simple_url_re = ...
    simple_url_2_re = ...
    word_split_re = ...
    mailto_template = ...
    url_template = ...
    def __call__(self, text, trim_url_limit=..., nofollow=..., autoescape=...):
        """
        If trim_url_limit is not None, truncate the URLs in the link text
        longer than this limit to trim_url_limit - 1 characters and append an
        ellipsis.

        If nofollow is True, give the links a rel="nofollow" attribute.

        If autoescape is True, autoescape the link text and URLs.
        """
        ...
    
    def handle_word(self, word, *, safe_input, trim_url_limit=..., nofollow=..., autoescape=...): # -> str | _Wrapped[(...), Unknown, (*args: Unknown, **kwargs: Unknown), Unknown] | SafeString:
        ...
    
    def trim_url(self, x, *, limit):
        ...
    
    def trim_punctuation(self, word): # -> tuple[Unknown | Literal[''], Unknown, Unknown | Literal['']]:
        """
        Trim trailing and wrapping punctuation from `word`. Return the items of
        the new state.
        """
        ...
    
    @staticmethod
    def is_email_simple(value): # -> bool:
        """Return True if value looks like an email address."""
        ...
    


urlizer = ...
@keep_lazy_text
def urlize(text, trim_url_limit=..., nofollow=..., autoescape=...):
    ...

def avoid_wrapping(value):
    """
    Avoid text wrapping in the middle of a phrase by adding non-breaking
    spaces where there previously were normal spaces.
    """
    ...

def html_safe(klass):
    """
    A decorator that defines the __html__ method. This helps non-Django
    templates to detect classes whose __str__ methods return SafeString.
    """
    ...

