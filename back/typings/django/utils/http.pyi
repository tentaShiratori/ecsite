"""
This type stub file was generated by pyright.
"""

ETAG_MATCH = ...
MONTHS = ...
__D = ...
__D2 = ...
__M = ...
__Y = ...
__Y2 = ...
__T = ...
RFC1123_DATE = ...
RFC850_DATE = ...
ASCTIME_DATE = ...
RFC3986_GENDELIMS = ...
RFC3986_SUBDELIMS = ...
def urlencode(query, doseq=...): # -> str:
    """
    A version of Python's urllib.parse.urlencode() function that can operate on
    MultiValueDict and non-string values.
    """
    ...

def http_date(epoch_seconds=...): # -> str:
    """
    Format the time to match the RFC1123 date format as specified by HTTP
    RFC7231 section 7.1.1.1.

    `epoch_seconds` is a floating point number expressed in seconds since the
    epoch, in UTC - such as that outputted by time.time(). If set to None, it
    defaults to the current time.

    Output a string in the format 'Wdy, DD Mon YYYY HH:MM:SS GMT'.
    """
    ...

def parse_http_date(date): # -> int:
    """
    Parse a date format as specified by HTTP RFC7231 section 7.1.1.1.

    The three formats allowed by the RFC are accepted, even if only the first
    one is still in widespread use.

    Return an integer expressed in seconds since the epoch, in UTC.
    """
    ...

def parse_http_date_safe(date): # -> int | None:
    """
    Same as parse_http_date, but return None if the input is invalid.
    """
    ...

def base36_to_int(s): # -> int:
    """
    Convert a base 36 string to an int. Raise ValueError if the input won't fit
    into an int.
    """
    ...

def int_to_base36(i): # -> str:
    """Convert an integer to a base36 string."""
    ...

def urlsafe_base64_encode(s): # -> str:
    """
    Encode a bytestring to a base64 string for use in URLs. Strip any trailing
    equal signs.
    """
    ...

def urlsafe_base64_decode(s): # -> bytes:
    """
    Decode a base64 encoded string. Add back any trailing equal signs that
    might have been stripped.
    """
    ...

def parse_etags(etag_str): # -> list[str] | list[Any]:
    """
    Parse a string of ETags given in an If-None-Match or If-Match header as
    defined by RFC 7232. Return a list of quoted ETags, or ['*'] if all ETags
    should be matched.
    """
    ...

def quote_etag(etag_str):
    """
    If the provided string is already a quoted ETag, return it. Otherwise, wrap
    the string in quotes, making it a strong ETag.
    """
    ...

def is_same_domain(host, pattern): # -> Literal[False]:
    """
    Return ``True`` if the host is either an exact match or a match
    to the wildcard pattern.

    Any pattern beginning with a period matches a domain and all of its
    subdomains. (e.g. ``.example.com`` matches ``example.com`` and
    ``foo.example.com``). Anything else is an exact string match.
    """
    ...

def url_has_allowed_host_and_scheme(url, allowed_hosts, require_https=...): # -> bool:
    """
    Return ``True`` if the url uses an allowed host and a safe scheme.

    Always return ``False`` on an empty url.

    If ``require_https`` is ``True``, only 'https' will be considered a valid
    scheme, as opposed to 'http' and 'https' with the default, ``False``.

    Note: "True" doesn't entail that a URL is "safe". It may still be e.g.
    quoted incorrectly. Ensure to also use django.utils.encoding.iri_to_uri()
    on the path component of untrusted URLs.
    """
    ...

def escape_leading_slashes(url): # -> str:
    """
    If redirecting to an absolute path (two leading slashes), a slash must be
    escaped to prevent browsers from handling the path as schemaless and
    redirecting to another host.
    """
    ...

def parse_header_parameters(line): # -> tuple[Unknown, dict[Unknown, Unknown]]:
    """
    Parse a Content-type like header.
    Return the main content-type and a dictionary of options.
    """
    ...

