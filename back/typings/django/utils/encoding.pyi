"""
This type stub file was generated by pyright.
"""

class DjangoUnicodeDecodeError(UnicodeDecodeError):
    def __init__(self, obj, *args) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    


def smart_str(s, encoding=..., strings_only=..., errors=...): # -> Promise | str:
    """
    Return a string representing 's'. Treat bytestrings using the 'encoding'
    codec.

    If strings_only is True, don't convert (some) non-string-like objects.
    """
    ...

_PROTECTED_TYPES = ...
def is_protected_type(obj): # -> bool:
    """Determine if the object instance is of a protected type.

    Objects of protected types are preserved as-is when passed to
    force_str(strings_only=True).
    """
    ...

def force_str(s, encoding=..., strings_only=..., errors=...): # -> str:
    """
    Similar to smart_str(), except that lazy instances are resolved to
    strings, rather than kept as lazy objects.

    If strings_only is True, don't convert (some) non-string-like objects.
    """
    ...

def smart_bytes(s, encoding=..., strings_only=..., errors=...): # -> Promise | bytes:
    """
    Return a bytestring version of 's', encoded as specified in 'encoding'.

    If strings_only is True, don't convert (some) non-string-like objects.
    """
    ...

def force_bytes(s, encoding=..., strings_only=..., errors=...): # -> bytes:
    """
    Similar to smart_bytes, except that lazy instances are resolved to
    strings, rather than kept as lazy objects.

    If strings_only is True, don't convert (some) non-string-like objects.
    """
    ...

def iri_to_uri(iri): # -> str:
    """
    Convert an Internationalized Resource Identifier (IRI) portion to a URI
    portion that is suitable for inclusion in a URL.

    This is the algorithm from section 3.1 of RFC 3987, slightly simplified
    since the input is assumed to be a string rather than an arbitrary byte
    stream.

    Take an IRI (string or UTF-8 bytes, e.g. '/I ♥ Django/' or
    b'/I \xe2\x99\xa5 Django/') and return a string containing the encoded
    result with ASCII chars only (e.g. '/I%20%E2%99%A5%20Django/').
    """
    ...

_ascii_ranges = ...
_hextobyte = ...
_hexdig = ...
def uri_to_iri(uri): # -> str:
    """
    Convert a Uniform Resource Identifier(URI) into an Internationalized
    Resource Identifier(IRI).

    This is the algorithm from section 3.2 of RFC 3987, excluding step 4.

    Take an URI in ASCII bytes (e.g. '/I%20%E2%99%A5%20Django/') and return
    a string containing the encoded result (e.g. '/I%20♥%20Django/').
    """
    ...

def escape_uri_path(path): # -> str:
    """
    Escape the unsafe characters from the path portion of a Uniform Resource
    Identifier (URI).
    """
    ...

def punycode(domain):
    """Return the Punycode of the given domain if it's non-ASCII."""
    ...

def repercent_broken_unicode(path):
    """
    As per section 3.2 of RFC 3987, step three of converting a URI into an IRI,
    repercent-encode any octet produced that is not part of a strictly legal
    UTF-8 octet sequence.
    """
    ...

def filepath_to_uri(path): # -> str:
    """Convert a file system path to a URI portion that is suitable for
    inclusion in a URL.

    Encode certain chars that would normally be recognized as special chars
    for URIs. Do not encode the ' character, as it is a valid character
    within URIs. See the encodeURIComponent() JavaScript function for details.
    """
    ...

def get_system_encoding(): # -> str:
    """
    The encoding for the character type functions. Fallback to 'ascii' if the
    #encoding is unsupported by Python or could not be determined. See tickets
    #10335 and #5846.
    """
    ...

DEFAULT_LOCALE_ENCODING = ...
