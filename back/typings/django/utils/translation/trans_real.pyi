"""
This type stub file was generated by pyright.
"""

import functools
import gettext as gettext_module
from django.core.signals import setting_changed
from django.dispatch import receiver

"""Translation helper functions."""
_translations = ...
_active = ...
_default = ...
CONTEXT_SEPARATOR = ...
ACCEPT_LANGUAGE_HEADER_MAX_LENGTH = ...
accept_language_re = ...
language_code_re = ...
language_code_prefix_re = ...
@receiver(setting_changed)
def reset_cache(*, setting, **kwargs): # -> None:
    """
    Reset global state when LANGUAGES setting has been changed, as some
    languages should no longer be accepted.
    """
    ...

class TranslationCatalog:
    """
    Simulate a dict for DjangoTranslation._catalog so as multiple catalogs
    with different plural equations are kept separate.
    """
    def __init__(self, trans=...) -> None:
        ...
    
    def __getitem__(self, key):
        ...
    
    def __setitem__(self, key, value): # -> None:
        ...
    
    def __contains__(self, key): # -> bool:
        ...
    
    def items(self): # -> Generator[Unknown | tuple[Unknown, Unknown], None, None]:
        ...
    
    def keys(self): # -> Generator[Unknown, None, None]:
        ...
    
    def update(self, trans): # -> None:
        ...
    
    def get(self, key, default=...): # -> object | None:
        ...
    
    def plural(self, msgid, num):
        ...
    


class DjangoTranslation(gettext_module.GNUTranslations):
    """
    Set up the GNUTranslations context with regard to output charset.

    This translation object will be constructed out of multiple GNUTranslations
    objects by merging their catalogs. It will construct an object for the
    requested language and add a fallback to the default language, if it's
    different from the requested language.
    """
    domain = ...
    def __init__(self, language, domain=..., localedirs=...) -> None:
        """Create a GNUTranslations() using many locale directories"""
        ...
    
    def __repr__(self): # -> LiteralString:
        ...
    
    def merge(self, other): # -> None:
        """Merge another translation into this catalog."""
        ...
    
    def language(self): # -> Unknown:
        """Return the translation language."""
        ...
    
    def to_language(self):
        """Return the translation language name."""
        ...
    
    def ngettext(self, msgid1, msgid2, n): # -> str:
        ...
    


def translation(language):
    """
    Return a translation object in the default 'django' domain.
    """
    ...

def activate(language): # -> None:
    """
    Fetch the translation object for a given language and install it as the
    current translation object for the current thread.
    """
    ...

def deactivate(): # -> None:
    """
    Uninstall the active translation object so that further _() calls resolve
    to the default translation object.
    """
    ...

def deactivate_all(): # -> None:
    """
    Make the active translation object a NullTranslations() instance. This is
    useful when we want delayed translations to appear as the original string
    for some reason.
    """
    ...

def get_language(): # -> Any:
    """Return the currently selected language."""
    ...

def get_language_bidi(): # -> bool:
    """
    Return selected language's BiDi layout.

    * False = left-to-right layout
    * True = right-to-left layout
    """
    ...

def catalog(): # -> Any:
    """
    Return the current active catalog for further processing.
    This can be used if you need to modify the catalog or want to access the
    whole message catalog instead of just translating one string.
    """
    ...

def gettext(message): # -> Any | _Wrapped[(...), Unknown, (*args: Unknown, **kwargs: Unknown), Unknown] | SafeString:
    """
    Translate the 'message' string. It uses the current thread to find the
    translation object to use. If no current translation is activated, the
    message will be run through the default translation object.
    """
    ...

def pgettext(context, message): # -> Any | _Wrapped[(...), Unknown, (*args: Unknown, **kwargs: Unknown), Unknown] | SafeString | str:
    ...

def gettext_noop(message):
    """
    Mark strings for translation but don't translate them now. This can be
    used to store strings in global variables that should stay in the base
    language (because they might be used externally) and will be translated
    later.
    """
    ...

def do_ntranslate(singular, plural, number, translation_function): # -> Any:
    ...

def ngettext(singular, plural, number): # -> Any:
    """
    Return a string of the translation of either the singular or plural,
    based on the number.
    """
    ...

def npgettext(context, singular, plural, number): # -> Any:
    ...

def all_locale_paths(): # -> list[Unknown]:
    """
    Return a list of paths to user-provides languages files.
    """
    ...

@functools.lru_cache(maxsize=1000)
def check_for_language(lang_code): # -> bool:
    """
    Check whether there is a global language file for the given language
    code. This is used to decide whether a user-provided language is
    available.

    lru_cache should have a maxsize to prevent from memory exhaustion attacks,
    as the provided language codes are taken from the HTTP request. See also
    <https://www.djangoproject.com/weblog/2007/oct/26/security-fix/>.
    """
    ...

@functools.lru_cache
def get_languages(): # -> dict[Any, Any]:
    """
    Cache of settings.LANGUAGES in a dictionary for easy lookups by key.
    Convert keys to lowercase as they should be treated as case-insensitive.
    """
    ...

@functools.lru_cache(maxsize=1000)
def get_supported_language_variant(lang_code, strict=...): # -> Any:
    """
    Return the language code that's listed in supported languages, possibly
    selecting a more generic variant. Raise LookupError if nothing is found.

    If `strict` is False (the default), look for a country-specific variant
    when neither the language code nor its generic variant is found.

    lru_cache should have a maxsize to prevent from memory exhaustion attacks,
    as the provided language codes are taken from the HTTP request. See also
    <https://www.djangoproject.com/weblog/2007/oct/26/security-fix/>.
    """
    ...

def get_language_from_path(path, strict=...): # -> Any | None:
    """
    Return the language code if there's a valid language code found in `path`.

    If `strict` is False (the default), look for a country-specific variant
    when neither the language code nor its generic variant is found.
    """
    ...

def get_language_from_request(request, check_path=...): # -> Any:
    """
    Analyze the request to find what language the user wants the system to
    show. Only languages listed in settings.LANGUAGES are taken into account.
    If the user requests a sublanguage where we have a main language, we send
    out the main language.

    If check_path is True, the URL path prefix will be checked for a language
    code, otherwise this is skipped for backwards compatibility.
    """
    ...

def parse_accept_lang_header(lang_string): # -> tuple[()] | tuple[Unknown, ...]:
    """
    Parse the value of the Accept-Language header up to a maximum length.

    The value of the header is truncated to a maximum length to avoid potential
    denial of service and memory exhaustion attacks. Excessive memory could be
    used if the raw value is very large as it would be cached due to the use of
    functools.lru_cache() to avoid repetitive parsing of common header values.
    """
    ...

