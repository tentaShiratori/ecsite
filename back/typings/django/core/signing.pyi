"""
This type stub file was generated by pyright.
"""

"""
Functions for creating and restoring url-safe signed JSON objects.

The format used looks like this:

>>> signing.dumps("hello")
'ImhlbGxvIg:1QaUZC:YIye-ze3TTx7gtSv422nZA4sgmk'

There are two components here, separated by a ':'. The first component is a
URLsafe base64 encoded JSON of the object passed to dumps(). The second
component is a base64 encoded hmac/SHA-256 hash of "$first_component:$secret"

signing.loads(s) checks the signature and returns the deserialized object.
If the signature fails, a BadSignature exception is raised.

>>> signing.loads("ImhlbGxvIg:1QaUZC:YIye-ze3TTx7gtSv422nZA4sgmk")
'hello'
>>> signing.loads("ImhlbGxvIg:1QaUZC:YIye-ze3TTx7gtSv42-modified")
...
BadSignature: Signature "ImhlbGxvIg:1QaUZC:YIye-ze3TTx7gtSv42-modified" does not match

You can optionally compress the JSON prior to base64 encoding it to save
space, using the compress=True argument. This checks if compression actually
helps and only applies compression if the result is a shorter string:

>>> signing.dumps(list(range(1, 20)), compress=True)
'.eJwFwcERACAIwLCF-rCiILN47r-GyZVJsNgkxaFxoDgxcOHGxMKD_T7vhAml:1QaUaL:BA0thEZrp4FQVXIXuOvYJtLJSrQ'

The fact that the string is compressed is signalled by the prefixed '.' at the
start of the base64 JSON.

There are 65 url-safe characters: the 64 used by url-safe base64 and the ':'.
These functions make use of all of them.
"""
_SEP_UNSAFE = ...
BASE62_ALPHABET = ...
class BadSignature(Exception):
    """Signature does not match."""
    ...


class SignatureExpired(BadSignature):
    """Signature timestamp is older than required max_age."""
    ...


def b62_encode(s): # -> str:
    ...

def b62_decode(s): # -> int:
    ...

def b64_encode(s): # -> bytes:
    ...

def b64_decode(s): # -> bytes:
    ...

def base64_hmac(salt, value, key, algorithm=...): # -> str:
    ...

def get_cookie_signer(salt=...): # -> Any:
    ...

class JSONSerializer:
    """
    Simple wrapper around json to be used in signing.dumps and
    signing.loads.
    """
    def dumps(self, obj): # -> bytes:
        ...
    
    def loads(self, data): # -> Any:
        ...
    


def dumps(obj, key=..., salt=..., serializer=..., compress=...): # -> str:
    """
    Return URL-safe, hmac signed base64 compressed JSON string. If key is
    None, use settings.SECRET_KEY instead. The hmac algorithm is the default
    Signer algorithm.

    If compress is True (not the default), check if compressing using zlib can
    save some space. Prepend a '.' to signify compression. This is included
    in the signature, to protect against zip bombs.

    Salt can be used to namespace the hash, so that a signed string is
    only valid for a given namespace. Leaving this at the default
    value or re-using a salt value across different parts of your
    application without good cause is a security risk.

    The serializer is expected to return a bytestring.
    """
    ...

def loads(s, key=..., salt=..., serializer=..., max_age=..., fallback_keys=...): # -> Any:
    """
    Reverse of dumps(), raise BadSignature if signature fails.

    The serializer is expected to accept a bytestring.
    """
    ...

class Signer:
    def __init__(self, key=..., sep=..., salt=..., algorithm=..., fallback_keys=...) -> None:
        ...
    
    def signature(self, value, key=...): # -> str:
        ...
    
    def sign(self, value): # -> str:
        ...
    
    def unsign(self, signed_value):
        ...
    
    def sign_object(self, obj, serializer=..., compress=...): # -> str:
        """
        Return URL-safe, hmac signed base64 compressed JSON string.

        If compress is True (not the default), check if compressing using zlib
        can save some space. Prepend a '.' to signify compression. This is
        included in the signature, to protect against zip bombs.

        The serializer is expected to return a bytestring.
        """
        ...
    
    def unsign_object(self, signed_obj, serializer=..., **kwargs): # -> Any:
        ...
    


class TimestampSigner(Signer):
    def timestamp(self): # -> str:
        ...
    
    def sign(self, value): # -> str:
        ...
    
    def unsign(self, value, max_age=...):
        """
        Retrieve original value and check it wasn't signed more
        than max_age seconds ago.
        """
        ...
    


