"""
This type stub file was generated by pyright.
"""

from email.mime.message import MIMEMessage
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

utf8_charset = ...
utf8_charset_qp = ...
DEFAULT_ATTACHMENT_MIME_TYPE = ...
RFC5322_EMAIL_LINE_LENGTH_LIMIT = ...
class BadHeaderError(ValueError):
    ...


ADDRESS_HEADERS = ...
def forbid_multi_line_headers(name, val, encoding): # -> tuple[Unknown, str]:
    """Forbid multi-line headers to prevent header injection."""
    ...

def sanitize_address(addr, encoding): # -> str:
    """
    Format a pair of (name, address) or an email address string.
    """
    ...

class MIMEMixin:
    def as_string(self, unixfrom=..., linesep=...): # -> str:
        """Return the entire formatted message as a string.
        Optional `unixfrom' when True, means include the Unix From_ envelope
        header.

        This overrides the default as_string() implementation to not mangle
        lines that begin with 'From '. See bug #13433 for details.
        """
        ...
    
    def as_bytes(self, unixfrom=..., linesep=...): # -> bytes:
        """Return the entire formatted message as bytes.
        Optional `unixfrom' when True, means include the Unix From_ envelope
        header.

        This overrides the default as_bytes() implementation to not mangle
        lines that begin with 'From '. See bug #13433 for details.
        """
        ...
    


class SafeMIMEMessage(MIMEMixin, MIMEMessage):
    def __setitem__(self, name, val): # -> None:
        ...
    


class SafeMIMEText(MIMEMixin, MIMEText):
    def __init__(self, _text, _subtype=..., _charset=...) -> None:
        ...
    
    def __setitem__(self, name, val): # -> None:
        ...
    
    def set_payload(self, payload, charset=...): # -> None:
        ...
    


class SafeMIMEMultipart(MIMEMixin, MIMEMultipart):
    def __init__(self, _subtype=..., boundary=..., _subparts=..., encoding=..., **_params) -> None:
        ...
    
    def __setitem__(self, name, val): # -> None:
        ...
    


class EmailMessage:
    """A container for email information."""
    content_subtype = ...
    mixed_subtype = ...
    encoding = ...
    def __init__(self, subject=..., body=..., from_email=..., to=..., bcc=..., connection=..., attachments=..., headers=..., cc=..., reply_to=...) -> None:
        """
        Initialize a single email message (which can be sent to multiple
        recipients).
        """
        ...
    
    def get_connection(self, fail_silently=...): # -> Any:
        ...
    
    def message(self): # -> SafeMIMEMultipart:
        ...
    
    def recipients(self): # -> list[Unknown]:
        """
        Return a list of all recipients of the email (includes direct
        addressees as well as Cc and Bcc entries).
        """
        ...
    
    def send(self, fail_silently=...): # -> Any | Literal[0]:
        """Send the email message."""
        ...
    
    def attach(self, filename=..., content=..., mimetype=...): # -> None:
        """
        Attach a file with the given filename and content. The filename can
        be omitted and the mimetype is guessed, if not provided.

        If the first parameter is a MIMEBase subclass, insert it directly
        into the resulting message attachments.

        For a text/* mimetype (guessed or specified), when a bytes object is
        specified as content, decode it as UTF-8. If that fails, set the
        mimetype to DEFAULT_ATTACHMENT_MIME_TYPE and don't decode the content.
        """
        ...
    
    def attach_file(self, path, mimetype=...): # -> None:
        """
        Attach a file from the filesystem.

        Set the mimetype to DEFAULT_ATTACHMENT_MIME_TYPE if it isn't specified
        and cannot be guessed.

        For a text/* mimetype (guessed or specified), decode the file's content
        as UTF-8. If that fails, set the mimetype to
        DEFAULT_ATTACHMENT_MIME_TYPE and don't decode the content.
        """
        ...
    


class EmailMultiAlternatives(EmailMessage):
    """
    A version of EmailMessage that makes it easy to send multipart/alternative
    messages. For example, including text and HTML versions of the text is
    made easier.
    """
    alternative_subtype = ...
    def __init__(self, subject=..., body=..., from_email=..., to=..., bcc=..., connection=..., attachments=..., headers=..., alternatives=..., cc=..., reply_to=...) -> None:
        """
        Initialize a single email message (which can be sent to multiple
        recipients).
        """
        ...
    
    def attach_alternative(self, content, mimetype): # -> None:
        """Attach an alternative content representation."""
        ...
    


