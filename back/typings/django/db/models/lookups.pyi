"""
This type stub file was generated by pyright.
"""

from django.db.models.expressions import Expression, Func
from django.db.models.fields import Field, IntegerField, UUIDField
from django.db.models.query_utils import RegisterLookupMixin
from django.utils.functional import cached_property

class Lookup(Expression):
    lookup_name = ...
    prepare_rhs = ...
    can_use_none_as_rhs = ...
    def __init__(self, lhs, rhs) -> None:
        ...
    
    def apply_bilateral_transforms(self, value):
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def batch_process_rhs(self, compiler, connection, rhs=...): # -> tuple[list[str], list[Unknown]]:
        ...
    
    def get_source_expressions(self): # -> list[Unknown | Value] | list[Unknown]:
        ...
    
    def set_source_expressions(self, new_exprs): # -> None:
        ...
    
    def get_prep_lookup(self): # -> Unknown | Value:
        ...
    
    def get_prep_lhs(self): # -> Unknown | Value:
        ...
    
    def get_db_prep_lookup(self, value, connection): # -> tuple[Literal['%s'], list[Unknown]]:
        ...
    
    def process_lhs(self, compiler, connection, lhs=...): # -> tuple[str | Unknown, Unknown]:
        ...
    
    def process_rhs(self, compiler, connection): # -> tuple[Unknown, Unknown] | tuple[Literal['%s'], list[Value | Unknown]]:
        ...
    
    def rhs_is_direct_value(self): # -> bool:
        ...
    
    def get_group_by_cols(self, alias=...): # -> list[Unknown]:
        ...
    
    def as_oracle(self, compiler, connection):
        ...
    
    @cached_property
    def output_field(self): # -> BooleanField:
        ...
    
    @property
    def identity(self): # -> tuple[Type[Lookup], Unknown | Value, Unknown]:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def resolve_expression(self, query=..., allow_joins=..., reuse=..., summarize=..., for_save=...): # -> Self@Lookup:
        ...
    
    def select_format(self, compiler, sql, params): # -> tuple[str | Unknown, Unknown]:
        ...
    


class Transform(RegisterLookupMixin, Func):
    """
    RegisterLookupMixin() is first so that get_lookup() and get_transform()
    first examine self and then check output_field.
    """
    bilateral = ...
    arity = ...
    @property
    def lhs(self): # -> F | Value:
        ...
    
    def get_bilateral_transforms(self): # -> list[Unknown]:
        ...
    


class BuiltinLookup(Lookup):
    def process_lhs(self, compiler, connection, lhs=...): # -> tuple[Unknown, list[Unknown]]:
        ...
    
    def as_sql(self, compiler, connection): # -> tuple[LiteralString, list[Unknown]]:
        ...
    
    def get_rhs_op(self, connection, rhs):
        ...
    


class FieldGetDbPrepValueMixin:
    """
    Some lookups require Field.get_db_prep_value() to be called on their
    inputs.
    """
    get_db_prep_lookup_value_is_iterable = ...
    def get_db_prep_lookup(self, value, connection): # -> tuple[Literal['%s'], list[Any | Unknown]]:
        ...
    


class FieldGetDbPrepValueIterableMixin(FieldGetDbPrepValueMixin):
    """
    Some lookups require Field.get_db_prep_value() to be called on each value
    in an iterable.
    """
    get_db_prep_lookup_value_is_iterable = ...
    def get_prep_lookup(self): # -> list[Unknown]:
        ...
    
    def process_rhs(self, compiler, connection): # -> tuple[tuple[Unknown | list[Unknown]], tuple[Unknown, ...]]:
        ...
    
    def resolve_expression_parameter(self, compiler, connection, sql, param): # -> tuple[Unknown, Unknown | list[Unknown]]:
        ...
    
    def batch_process_rhs(self, compiler, connection, rhs=...): # -> tuple[tuple[Unknown | list[Unknown]], tuple[Unknown, ...]]:
        ...
    


class PostgresOperatorLookup(FieldGetDbPrepValueMixin, Lookup):
    """Lookup defined by operators on PostgreSQL."""
    postgres_operator = ...
    def as_postgresql(self, compiler, connection): # -> tuple[str, tuple[Unknown, ...]]:
        ...
    


@Field.register_lookup
class Exact(FieldGetDbPrepValueMixin, BuiltinLookup):
    lookup_name = ...
    def get_prep_lookup(self): # -> Unknown | Value:
        ...
    
    def as_sql(self, compiler, connection): # -> tuple[Unknown, list[Unknown]] | tuple[LiteralString, list[Unknown]]:
        ...
    


@Field.register_lookup
class IExact(BuiltinLookup):
    lookup_name = ...
    prepare_rhs = ...
    def process_rhs(self, qn, connection): # -> tuple[Unknown | Literal['%s'], Unknown | list[Value | Unknown]]:
        ...
    


@Field.register_lookup
class GreaterThan(FieldGetDbPrepValueMixin, BuiltinLookup):
    lookup_name = ...


@Field.register_lookup
class GreaterThanOrEqual(FieldGetDbPrepValueMixin, BuiltinLookup):
    lookup_name = ...


@Field.register_lookup
class LessThan(FieldGetDbPrepValueMixin, BuiltinLookup):
    lookup_name = ...


@Field.register_lookup
class LessThanOrEqual(FieldGetDbPrepValueMixin, BuiltinLookup):
    lookup_name = ...


class IntegerFieldFloatRounding:
    """
    Allow floats to work as query values for IntegerField. Without this, the
    decimal portion of the float would always be discarded.
    """
    def get_prep_lookup(self):
        ...
    


@IntegerField.register_lookup
class IntegerGreaterThanOrEqual(IntegerFieldFloatRounding, GreaterThanOrEqual):
    ...


@IntegerField.register_lookup
class IntegerLessThan(IntegerFieldFloatRounding, LessThan):
    ...


@Field.register_lookup
class In(FieldGetDbPrepValueIterableMixin, BuiltinLookup):
    lookup_name = ...
    def get_prep_lookup(self): # -> list[Unknown]:
        ...
    
    def process_rhs(self, compiler, connection): # -> tuple[Unknown, tuple[Unknown, ...]] | tuple[tuple[Unknown | list[Unknown]], tuple[Unknown, ...]]:
        ...
    
    def get_rhs_op(self, connection, rhs):
        ...
    
    def as_sql(self, compiler, connection): # -> tuple[str, list[Unknown]] | tuple[LiteralString, list[Unknown]]:
        ...
    
    def split_parameter_list_as_sql(self, compiler, connection): # -> tuple[str, list[Unknown]]:
        ...
    


class PatternLookup(BuiltinLookup):
    param_pattern = ...
    prepare_rhs = ...
    def get_rhs_op(self, connection, rhs):
        ...
    
    def process_rhs(self, qn, connection): # -> tuple[Unknown | Literal['%s'], Unknown | list[Value | Unknown]]:
        ...
    


@Field.register_lookup
class Contains(PatternLookup):
    lookup_name = ...


@Field.register_lookup
class IContains(Contains):
    lookup_name = ...


@Field.register_lookup
class StartsWith(PatternLookup):
    lookup_name = ...
    param_pattern = ...


@Field.register_lookup
class IStartsWith(StartsWith):
    lookup_name = ...


@Field.register_lookup
class EndsWith(PatternLookup):
    lookup_name = ...
    param_pattern = ...


@Field.register_lookup
class IEndsWith(EndsWith):
    lookup_name = ...


@Field.register_lookup
class Range(FieldGetDbPrepValueIterableMixin, BuiltinLookup):
    lookup_name = ...
    def get_rhs_op(self, connection, rhs): # -> LiteralString:
        ...
    


@Field.register_lookup
class IsNull(BuiltinLookup):
    lookup_name = ...
    prepare_rhs = ...
    def as_sql(self, compiler, connection): # -> tuple[Unknown, Unknown]:
        ...
    


@Field.register_lookup
class Regex(BuiltinLookup):
    lookup_name = ...
    prepare_rhs = ...
    def as_sql(self, compiler, connection): # -> tuple[LiteralString, list[Unknown]] | tuple[Unknown, Unknown | list[Unknown]]:
        ...
    


@Field.register_lookup
class IRegex(Regex):
    lookup_name = ...


class YearLookup(Lookup):
    def year_lookup_bounds(self, connection, year):
        ...
    
    def as_sql(self, compiler, connection): # -> tuple[str, Unknown]:
        ...
    
    def get_direct_rhs_sql(self, connection, rhs):
        ...
    
    def get_bound_params(self, start, finish):
        ...
    


class YearExact(YearLookup, Exact):
    def get_direct_rhs_sql(self, connection, rhs): # -> Literal['BETWEEN %s AND %s']:
        ...
    
    def get_bound_params(self, start, finish): # -> tuple[Unknown, Unknown]:
        ...
    


class YearGt(YearLookup, GreaterThan):
    def get_bound_params(self, start, finish): # -> tuple[Unknown]:
        ...
    


class YearGte(YearLookup, GreaterThanOrEqual):
    def get_bound_params(self, start, finish): # -> tuple[Unknown]:
        ...
    


class YearLt(YearLookup, LessThan):
    def get_bound_params(self, start, finish): # -> tuple[Unknown]:
        ...
    


class YearLte(YearLookup, LessThanOrEqual):
    def get_bound_params(self, start, finish): # -> tuple[Unknown]:
        ...
    


class UUIDTextMixin:
    """
    Strip hyphens from a value when filtering a UUIDField on backends without
    a native datatype for UUID.
    """
    def process_rhs(self, qn, connection): # -> tuple[Unknown, Unknown]:
        ...
    


@UUIDField.register_lookup
class UUIDIExact(UUIDTextMixin, IExact):
    ...


@UUIDField.register_lookup
class UUIDContains(UUIDTextMixin, Contains):
    ...


@UUIDField.register_lookup
class UUIDIContains(UUIDTextMixin, IContains):
    ...


@UUIDField.register_lookup
class UUIDStartsWith(UUIDTextMixin, StartsWith):
    ...


@UUIDField.register_lookup
class UUIDIStartsWith(UUIDTextMixin, IStartsWith):
    ...


@UUIDField.register_lookup
class UUIDEndsWith(UUIDTextMixin, EndsWith):
    ...


@UUIDField.register_lookup
class UUIDIEndsWith(UUIDTextMixin, IEndsWith):
    ...


