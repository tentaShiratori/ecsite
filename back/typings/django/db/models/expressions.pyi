"""
This type stub file was generated by pyright.
"""

from django.utils.deconstruct import deconstructible
from django.utils.functional import cached_property

class SQLiteNumericMixin:
    """
    Some expressions with output_field=DecimalField() must be cast to
    numeric to be properly filtered.
    """
    def as_sqlite(self, compiler, connection, **extra_context): # -> tuple[Unknown, Unknown]:
        ...
    


class Combinable:
    """
    Provide the ability to combine one or two objects with
    some connector. For example F('foo') + F('bar').
    """
    ADD = ...
    SUB = ...
    MUL = ...
    DIV = ...
    POW = ...
    MOD = ...
    BITAND = ...
    BITOR = ...
    BITLEFTSHIFT = ...
    BITRIGHTSHIFT = ...
    BITXOR = ...
    def __neg__(self): # -> CombinedExpression:
        ...
    
    def __add__(self, other): # -> CombinedExpression:
        ...
    
    def __sub__(self, other): # -> CombinedExpression:
        ...
    
    def __mul__(self, other): # -> CombinedExpression:
        ...
    
    def __truediv__(self, other): # -> CombinedExpression:
        ...
    
    def __mod__(self, other): # -> CombinedExpression:
        ...
    
    def __pow__(self, other): # -> CombinedExpression:
        ...
    
    def __and__(self, other): # -> Q:
        ...
    
    def bitand(self, other): # -> CombinedExpression:
        ...
    
    def bitleftshift(self, other): # -> CombinedExpression:
        ...
    
    def bitrightshift(self, other): # -> CombinedExpression:
        ...
    
    def __xor__(self, other): # -> Q:
        ...
    
    def bitxor(self, other): # -> CombinedExpression:
        ...
    
    def __or__(self, other): # -> Q:
        ...
    
    def bitor(self, other): # -> CombinedExpression:
        ...
    
    def __radd__(self, other): # -> CombinedExpression:
        ...
    
    def __rsub__(self, other): # -> CombinedExpression:
        ...
    
    def __rmul__(self, other): # -> CombinedExpression:
        ...
    
    def __rtruediv__(self, other): # -> CombinedExpression:
        ...
    
    def __rmod__(self, other): # -> CombinedExpression:
        ...
    
    def __rpow__(self, other): # -> CombinedExpression:
        ...
    
    def __rand__(self, other):
        ...
    
    def __ror__(self, other):
        ...
    
    def __rxor__(self, other):
        ...
    


class BaseExpression:
    """Base class for all query expressions."""
    empty_result_set_value = ...
    is_summary = ...
    _output_field_resolved_to_none = ...
    filterable = ...
    window_compatible = ...
    def __init__(self, output_field=...) -> None:
        ...
    
    def __getstate__(self): # -> dict[str, Any]:
        ...
    
    def get_db_converters(self, connection):
        ...
    
    def get_source_expressions(self): # -> list[Unknown]:
        ...
    
    def set_source_expressions(self, exprs): # -> None:
        ...
    
    def as_sql(self, compiler, connection):
        """
        Responsible for returning a (sql, [params]) tuple to be included
        in the current query.

        Different backends can provide their own implementation, by
        providing an `as_{vendor}` method and patching the Expression:

        ```
        def override_as_sql(self, compiler, connection):
            # custom logic
            return super().as_sql(compiler, connection)
        setattr(Expression, 'as_' + connection.vendor, override_as_sql)
        ```

        Arguments:
         * compiler: the query compiler responsible for generating the query.
           Must have a compile method, returning a (sql, [params]) tuple.
           Calling compiler(value) will return a quoted `value`.

         * connection: the database connection used for the current query.

        Return: (sql, params)
          Where `sql` is a string containing ordered sql parameters to be
          replaced with the elements of the list `params`.
        """
        ...
    
    @cached_property
    def contains_aggregate(self): # -> bool:
        ...
    
    @cached_property
    def contains_over_clause(self): # -> bool:
        ...
    
    @cached_property
    def contains_column_references(self): # -> bool:
        ...
    
    def resolve_expression(self, query=..., allow_joins=..., reuse=..., summarize=..., for_save=...): # -> Self@BaseExpression:
        """
        Provide the chance to do any preprocessing or validation before being
        added to the query.

        Arguments:
         * query: the backend query implementation
         * allow_joins: boolean allowing or denying use of joins
           in this query
         * reuse: a set of reusable joins for multijoins
         * summarize: a terminal aggregate clause
         * for_save: whether this expression about to be used in a save or update

        Return: an Expression to be added to the query.
        """
        ...
    
    @property
    def conditional(self): # -> bool:
        ...
    
    @property
    def field(self): # -> cached_property:
        ...
    
    @cached_property
    def output_field(self):
        """Return the output type of this expressions."""
        ...
    
    @cached_property
    def convert_value(self): # -> ((value: Unknown, expression: Unknown, connection: Unknown) -> (float | None)) | ((value: Unknown, expression: Unknown, connection: Unknown) -> (int | None)) | ((value: Unknown, expression: Unknown, connection: Unknown) -> (Decimal | None)) | ((value: Unknown, expression: Unknown, connection: Unknown) -> Unknown):
        """
        Expressions provide their own converters because users have the option
        of manually specifying the output_field which may be a different type
        from the one the database returns.
        """
        ...
    
    def get_lookup(self, lookup):
        ...
    
    def get_transform(self, name):
        ...
    
    def relabeled_clone(self, change_map): # -> Self@BaseExpression:
        ...
    
    def replace_references(self, references_map): # -> Self@BaseExpression:
        ...
    
    def copy(self): # -> Self@BaseExpression:
        ...
    
    def prefix_references(self, prefix): # -> Self@BaseExpression:
        ...
    
    def get_group_by_cols(self, alias=...): # -> list[Self@BaseExpression] | list[Unknown]:
        ...
    
    def get_source_fields(self): # -> list[Unknown]:
        """Return the underlying field types used by this aggregate."""
        ...
    
    def asc(self, **kwargs): # -> OrderBy:
        ...
    
    def desc(self, **kwargs): # -> OrderBy:
        ...
    
    def reverse_ordering(self): # -> Self@BaseExpression:
        ...
    
    def flatten(self): # -> Generator[Self@BaseExpression | Unknown, None, None]:
        """
        Recursively yield this expression and all subexpressions, in
        depth-first order.
        """
        ...
    
    def select_format(self, compiler, sql, params): # -> tuple[Unknown, Unknown]:
        """
        Custom format for select clauses. For example, EXISTS expressions need
        to be wrapped in CASE WHEN on Oracle.
        """
        ...
    


@deconstructible
class Expression(BaseExpression, Combinable):
    """An expression that can be combined with other expressions."""
    @cached_property
    def identity(self): # -> tuple[Type[Expression], ...]:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    


NoneType = ...
_connector_combinations = ...
_connector_combinators = ...
def register_combinable_fields(lhs, connector, rhs, result): # -> None:
    """
    Register combinable types:
        lhs <connector> rhs -> result
    e.g.
        register_combinable_fields(
            IntegerField, Combinable.ADD, FloatField, FloatField
        )
    """
    ...

class CombinedExpression(SQLiteNumericMixin, Expression):
    def __init__(self, lhs, connector, rhs, output_field=...) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __str__(self) -> str:
        ...
    
    def get_source_expressions(self): # -> list[Unknown]:
        ...
    
    def set_source_expressions(self, exprs): # -> None:
        ...
    
    def as_sql(self, compiler, connection): # -> tuple[Unknown, list[Unknown]]:
        ...
    
    def resolve_expression(self, query=..., allow_joins=..., reuse=..., summarize=..., for_save=...): # -> Self@CombinedExpression | DurationExpression | TemporalSubtraction:
        ...
    


class DurationExpression(CombinedExpression):
    def compile(self, side, compiler, connection): # -> tuple[Unknown, Unknown]:
        ...
    
    def as_sql(self, compiler, connection): # -> tuple[Unknown, list[Unknown]]:
        ...
    
    def as_sqlite(self, compiler, connection, **extra_context): # -> tuple[Unknown, list[Unknown]]:
        ...
    


class TemporalSubtraction(CombinedExpression):
    output_field = ...
    def __init__(self, lhs, rhs) -> None:
        ...
    
    def as_sql(self, compiler, connection):
        ...
    


@deconstructible(path="django.db.models.F")
class F(Combinable):
    """An object capable of resolving references to existing query objects."""
    def __init__(self, name) -> None:
        """
        Arguments:
         * name: the name of the field this expression references
        """
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def resolve_expression(self, query=..., allow_joins=..., reuse=..., summarize=..., for_save=...):
        ...
    
    def replace_references(self, references_map):
        ...
    
    def asc(self, **kwargs): # -> OrderBy:
        ...
    
    def desc(self, **kwargs): # -> OrderBy:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    


class ResolvedOuterRef(F):
    """
    An object that contains a reference to an outer query.

    In this case, the reference to the outer query has been resolved because
    the inner query has been used as a subquery.
    """
    contains_aggregate = ...
    def as_sql(self, *args, **kwargs):
        ...
    
    def resolve_expression(self, *args, **kwargs):
        ...
    
    def relabeled_clone(self, relabels): # -> Self@ResolvedOuterRef:
        ...
    
    def get_group_by_cols(self, alias=...): # -> list[Unknown]:
        ...
    


class OuterRef(F):
    contains_aggregate = ...
    def resolve_expression(self, *args, **kwargs): # -> OuterRef | ResolvedOuterRef:
        ...
    
    def relabeled_clone(self, relabels): # -> Self@OuterRef:
        ...
    


@deconstructible(path="django.db.models.Func")
class Func(SQLiteNumericMixin, Expression):
    """An SQL function call."""
    function = ...
    template = ...
    arg_joiner = ...
    arity = ...
    def __init__(self, *expressions, output_field=..., **extra) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def get_source_expressions(self): # -> list[Unknown | F | Value]:
        ...
    
    def set_source_expressions(self, exprs): # -> None:
        ...
    
    def resolve_expression(self, query=..., allow_joins=..., reuse=..., summarize=..., for_save=...): # -> Self@Func:
        ...
    
    def as_sql(self, compiler, connection, function=..., template=..., arg_joiner=..., **extra_context): # -> tuple[Unknown | str, list[Unknown]]:
        ...
    
    def copy(self): # -> Self@Func:
        ...
    


@deconstructible(path="django.db.models.Value")
class Value(SQLiteNumericMixin, Expression):
    """Represent a wrapped value as a node within an expression."""
    for_save = ...
    def __init__(self, value, output_field=...) -> None:
        """
        Arguments:
         * value: the value this expression represents. The value will be
           added into the sql parameter list and properly quoted.

         * output_field: an instance of the model field type that this
           expression will return, such as IntegerField() or CharField().
        """
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def as_sql(self, compiler, connection): # -> tuple[Unknown, list[Unknown]] | tuple[Literal['NULL'], list[Unknown]] | tuple[Literal['%s'], list[Unknown]]:
        ...
    
    def resolve_expression(self, query=..., allow_joins=..., reuse=..., summarize=..., for_save=...): # -> Self@Value:
        ...
    
    def get_group_by_cols(self, alias=...): # -> list[Unknown]:
        ...
    
    @property
    def empty_result_set_value(self): # -> Unknown:
        ...
    


class RawSQL(Expression):
    def __init__(self, sql, params, output_field=...) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def as_sql(self, compiler, connection): # -> tuple[LiteralString, Unknown]:
        ...
    
    def get_group_by_cols(self, alias=...): # -> list[Self@RawSQL]:
        ...
    
    def resolve_expression(self, query=..., allow_joins=..., reuse=..., summarize=..., for_save=...): # -> Self@RawSQL:
        ...
    


class Star(Expression):
    def __repr__(self): # -> Literal['\'*\'']:
        ...
    
    def as_sql(self, compiler, connection): # -> tuple[Literal['*'], list[Unknown]]:
        ...
    


class Col(Expression):
    contains_column_references = ...
    possibly_multivalued = ...
    def __init__(self, alias, target, output_field=...) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def as_sql(self, compiler, connection): # -> tuple[LiteralString, list[Unknown]]:
        ...
    
    def relabeled_clone(self, relabels): # -> Self@Col | Col:
        ...
    
    def get_group_by_cols(self, alias=...): # -> list[Self@Col]:
        ...
    
    def get_db_converters(self, connection):
        ...
    


class Ref(Expression):
    """
    Reference to column alias of the query. For example, Ref('sum_cost') in
    qs.annotate(sum_cost=Sum('cost')) query.
    """
    def __init__(self, refs, source) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def get_source_expressions(self): # -> list[Unknown]:
        ...
    
    def set_source_expressions(self, exprs): # -> None:
        ...
    
    def resolve_expression(self, query=..., allow_joins=..., reuse=..., summarize=..., for_save=...): # -> Self@Ref:
        ...
    
    def relabeled_clone(self, relabels): # -> Self@Ref:
        ...
    
    def as_sql(self, compiler, connection): # -> tuple[Unknown, list[Unknown]]:
        ...
    
    def get_group_by_cols(self, alias=...): # -> list[Self@Ref]:
        ...
    


class ExpressionList(Func):
    """
    An expression containing multiple expressions. Can be used to provide a
    list of expressions as an argument to another expression, like a partition
    clause.
    """
    template = ...
    def __init__(self, *expressions, **extra) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    def as_sqlite(self, compiler, connection, **extra_context): # -> tuple[Unknown, list[Unknown]]:
        ...
    


class OrderByList(Func):
    template = ...
    def __init__(self, *expressions, **extra) -> None:
        ...
    
    def as_sql(self, *args, **kwargs): # -> tuple[Literal[''], tuple[()]] | tuple[Unknown, list[Unknown]]:
        ...
    


@deconstructible(path="django.db.models.ExpressionWrapper")
class ExpressionWrapper(SQLiteNumericMixin, Expression):
    """
    An expression that can wrap another expression so that it can provide
    extra context to the inner expression, such as the output_field.
    """
    def __init__(self, expression, output_field) -> None:
        ...
    
    def set_source_expressions(self, exprs): # -> None:
        ...
    
    def get_source_expressions(self): # -> list[Unknown]:
        ...
    
    def get_group_by_cols(self, alias=...): # -> list[Expression] | list[Unknown] | list[Self@ExpressionWrapper]:
        ...
    
    def as_sql(self, compiler, connection):
        ...
    
    def __repr__(self): # -> str:
        ...
    


@deconstructible(path="django.db.models.When")
class When(Expression):
    template = ...
    conditional = ...
    def __init__(self, condition=..., then=..., **lookups) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def get_source_expressions(self): # -> list[Unknown]:
        ...
    
    def set_source_expressions(self, exprs): # -> None:
        ...
    
    def get_source_fields(self): # -> list[Unknown | cached_property]:
        ...
    
    def resolve_expression(self, query=..., allow_joins=..., reuse=..., summarize=..., for_save=...): # -> Self@When:
        ...
    
    def as_sql(self, compiler, connection, template=..., **extra_context): # -> tuple[Unknown | str, list[Unknown]]:
        ...
    
    def get_group_by_cols(self, alias=...): # -> list[Unknown]:
        ...
    


@deconstructible(path="django.db.models.Case")
class Case(SQLiteNumericMixin, Expression):
    """
    An SQL searched CASE expression:

        CASE
            WHEN n > 0
                THEN 'positive'
            WHEN n < 0
                THEN 'negative'
            ELSE 'zero'
        END
    """
    template = ...
    case_joiner = ...
    def __init__(self, *cases, default=..., output_field=..., **extra) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def get_source_expressions(self): # -> list[Unknown]:
        ...
    
    def set_source_expressions(self, exprs): # -> None:
        ...
    
    def resolve_expression(self, query=..., allow_joins=..., reuse=..., summarize=..., for_save=...): # -> Self@Case:
        ...
    
    def copy(self): # -> Self@Case:
        ...
    
    def as_sql(self, compiler, connection, template=..., case_joiner=..., **extra_context): # -> tuple[Unknown, Unknown] | tuple[Unknown | str, list[Unknown]]:
        ...
    
    def get_group_by_cols(self, alias=...): # -> list[Unknown] | list[Self@Case]:
        ...
    


class Subquery(BaseExpression, Combinable):
    """
    An explicit subquery. It may contain OuterRef() references to the outer
    query which will be resolved when it is applied to that query.
    """
    template = ...
    contains_aggregate = ...
    empty_result_set_value = ...
    def __init__(self, queryset, output_field=..., **extra) -> None:
        ...
    
    def get_source_expressions(self): # -> list[Any | Unknown]:
        ...
    
    def set_source_expressions(self, exprs): # -> None:
        ...
    
    def copy(self): # -> Self@Subquery:
        ...
    
    @property
    def external_aliases(self): # -> Any:
        ...
    
    def get_external_cols(self): # -> Any:
        ...
    
    def as_sql(self, compiler, connection, template=..., query=..., **extra_context): # -> tuple[Unknown | str, Unknown | Any]:
        ...
    
    def get_group_by_cols(self, alias=...): # -> list[Ref] | Any:
        ...
    


class Exists(Subquery):
    template = ...
    output_field = ...
    def __init__(self, queryset, negated=..., **kwargs) -> None:
        ...
    
    def __invert__(self): # -> Self@Exists:
        ...
    
    def get_group_by_cols(self, alias=...): # -> list[Self@Exists] | list[Ref] | Any:
        ...
    
    def as_sql(self, compiler, connection, template=..., **extra_context): # -> tuple[Literal['1=1'], tuple[()]] | tuple[str | Unknown, Any | Unknown]:
        ...
    
    def select_format(self, compiler, sql, params): # -> tuple[str | Unknown, Unknown]:
        ...
    


@deconstructible(path="django.db.models.OrderBy")
class OrderBy(Expression):
    template = ...
    conditional = ...
    def __init__(self, expression, descending=..., nulls_first=..., nulls_last=...) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def set_source_expressions(self, exprs): # -> None:
        ...
    
    def get_source_expressions(self): # -> list[Unknown]:
        ...
    
    def as_sql(self, compiler, connection, template=..., **extra_context): # -> tuple[Unknown | str, Unknown]:
        ...
    
    def as_oracle(self, compiler, connection): # -> tuple[Unknown | str, Unknown]:
        ...
    
    def get_group_by_cols(self, alias=...): # -> list[Unknown]:
        ...
    
    def reverse_ordering(self): # -> Self@OrderBy:
        ...
    
    def asc(self): # -> None:
        ...
    
    def desc(self): # -> None:
        ...
    


class Window(SQLiteNumericMixin, Expression):
    template = ...
    contains_aggregate = ...
    contains_over_clause = ...
    filterable = ...
    def __init__(self, expression, partition_by=..., order_by=..., frame=..., output_field=...) -> None:
        ...
    
    def get_source_expressions(self): # -> list[Unknown]:
        ...
    
    def set_source_expressions(self, exprs): # -> None:
        ...
    
    def as_sql(self, compiler, connection, template=...): # -> tuple[Unknown | str, tuple[Unknown | Any, ...]]:
        ...
    
    def as_sqlite(self, compiler, connection): # -> tuple[Unknown, Unknown] | tuple[str, tuple[Unknown | Any, ...]]:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def get_group_by_cols(self, alias=...): # -> list[Unknown]:
        ...
    


class WindowFrame(Expression):
    """
    Model the frame clause in window expressions. There are two types of frame
    clauses which are subclasses, however, all processing and validation (by no
    means intended to be complete) is done here. Thus, providing an end for a
    frame is optional (the default is UNBOUNDED FOLLOWING, which is the last
    row in the frame).
    """
    template = ...
    def __init__(self, start=..., end=...) -> None:
        ...
    
    def set_source_expressions(self, exprs): # -> None:
        ...
    
    def get_source_expressions(self): # -> list[Value | Unknown]:
        ...
    
    def as_sql(self, compiler, connection): # -> tuple[str, list[Unknown]]:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def get_group_by_cols(self, alias=...): # -> list[Unknown]:
        ...
    
    def __str__(self) -> str:
        ...
    
    def window_frame_start_end(self, connection, start, end):
        ...
    


class RowRange(WindowFrame):
    frame_type = ...
    def window_frame_start_end(self, connection, start, end):
        ...
    


class ValueRange(WindowFrame):
    frame_type = ...
    def window_frame_start_end(self, connection, start, end):
        ...
    


