"""
This type stub file was generated by pyright.
"""

from django.db import IntegrityError

class ProtectedError(IntegrityError):
    def __init__(self, msg, protected_objects) -> None:
        ...
    


class RestrictedError(IntegrityError):
    def __init__(self, msg, restricted_objects) -> None:
        ...
    


def CASCADE(collector, field, sub_objs, using): # -> None:
    ...

def PROTECT(collector, field, sub_objs, using):
    ...

def RESTRICT(collector, field, sub_objs, using): # -> None:
    ...

def SET(value): # -> (collector: Unknown, field: Unknown, sub_objs: Unknown, using: Unknown) -> None:
    ...

def SET_NULL(collector, field, sub_objs, using): # -> None:
    ...

def SET_DEFAULT(collector, field, sub_objs, using): # -> None:
    ...

def DO_NOTHING(collector, field, sub_objs, using): # -> None:
    ...

def get_candidate_relations_to_delete(opts): # -> Generator[Unknown, None, None]:
    ...

class Collector:
    def __init__(self, using, origin=...) -> None:
        ...
    
    def add(self, objs, source=..., nullable=..., reverse_dependency=...): # -> list[Unknown]:
        """
        Add 'objs' to the collection of objects to be deleted.  If the call is
        the result of a cascade, 'source' should be the model that caused it,
        and 'nullable' should be set to True if the relation can be null.

        Return a list of all objects that were not already collected.
        """
        ...
    
    def add_dependency(self, model, dependency, reverse_dependency=...): # -> None:
        ...
    
    def add_field_update(self, field, value, objs): # -> None:
        """
        Schedule a field update. 'objs' must be a homogeneous iterable
        collection of model instances (e.g. a QuerySet).
        """
        ...
    
    def add_restricted_objects(self, field, objs): # -> None:
        ...
    
    def clear_restricted_objects_from_set(self, model, objs): # -> None:
        ...
    
    def clear_restricted_objects_from_queryset(self, model, qs): # -> None:
        ...
    
    def can_fast_delete(self, objs, from_field=...): # -> bool:
        """
        Determine if the objects in the given queryset-like or single object
        can be fast-deleted. This can be done if there are no cascades, no
        parents and no signal listeners for the object class.

        The 'from_field' tells where we are coming from - we need this to
        determine if the objects are in fact to be deleted. Allow also
        skipping parent -> child -> parent chain preventing fast delete of
        the child.
        """
        ...
    
    def get_del_batches(self, objs, fields): # -> list[Unknown]:
        """
        Return the objs in suitably sized batches for the used connection.
        """
        ...
    
    def collect(self, objs, source=..., nullable=..., collect_related=..., source_attr=..., reverse_dependency=..., keep_parents=..., fail_on_restricted=...): # -> None:
        """
        Add 'objs' to the collection of objects to be deleted as well as all
        parent instances.  'objs' must be a homogeneous iterable collection of
        model instances (e.g. a QuerySet).  If 'collect_related' is True,
        related objects will be handled by their respective on_delete handler.

        If the call is the result of a cascade, 'source' should be the model
        that caused it and 'nullable' should be set to True, if the relation
        can be null.

        If 'reverse_dependency' is True, 'source' will be deleted before the
        current model, rather than after. (Needed for cascading to parent
        models, the one case in which the cascade follows the forwards
        direction of an FK rather than the reverse direction.)

        If 'keep_parents' is True, data of parent model's will be not deleted.

        If 'fail_on_restricted' is False, error won't be raised even if it's
        prohibited to delete such objects due to RESTRICT, that defers
        restricted object checking in recursive calls where the top-level call
        may need to collect more objects to determine whether restricted ones
        can be deleted.
        """
        ...
    
    def related_objects(self, related_model, related_fields, objs):
        """
        Get a QuerySet of the related model to objs via related fields.
        """
        ...
    
    def instances_with_model(self): # -> Generator[tuple[Unknown, Unknown], None, None]:
        ...
    
    def sort(self): # -> None:
        ...
    
    def delete(self): # -> tuple[Any | Unknown | int, dict[Unknown, Any | Unknown | int]] | tuple[int, dict[Unknown, int]]:
        ...
    


