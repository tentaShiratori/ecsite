"""
This type stub file was generated by pyright.
"""

import functools
from django.utils.functional import cached_property
from . import Field
from .mixins import FieldCacheMixin
from .related_descriptors import ForeignKeyDeferredAttribute, ForwardManyToOneDescriptor, ForwardOneToOneDescriptor, ReverseManyToOneDescriptor, ReverseOneToOneDescriptor
from .reverse_related import ForeignObjectRel, ManyToManyRel, ManyToOneRel, OneToOneRel

RECURSIVE_RELATIONSHIP_CONSTANT = ...
def resolve_relation(scope_model, relation): # -> str:
    """
    Transform relation into a model or fully-qualified model string of the form
    "app_label.ModelName", relative to scope_model.

    The relation argument can be:
      * RECURSIVE_RELATIONSHIP_CONSTANT, i.e. the string "self", in which case
        the model argument will be returned.
      * A bare model name without an app_label, in which case scope_model's
        app_label will be prepended.
      * An "app_label.ModelName" string.
      * A model class, which will be returned unchanged.
    """
    ...

def lazy_related_operation(function, model, *related_models, **kwargs):
    """
    Schedule `function` to be called once `model` and all `related_models`
    have been imported and registered with the app registry. `function` will
    be called with the newly-loaded model classes as its positional arguments,
    plus any optional keyword arguments.

    The `model` argument must be a model class. Each subsequent positional
    argument is another model, or a reference to another model - see
    `resolve_relation()` for the various forms these may take. Any relative
    references will be resolved relative to `model`.

    This is a convenience wrapper for `Apps.lazy_model_operation` - the app
    registry model used is the one found in `model._meta.apps`.
    """
    ...

class RelatedField(FieldCacheMixin, Field):
    """Base class that all relational fields inherit from."""
    one_to_many = ...
    one_to_one = ...
    many_to_many = ...
    many_to_one = ...
    def __init__(self, related_name=..., related_query_name=..., limit_choices_to=..., **kwargs) -> None:
        ...
    
    @cached_property
    def related_model(self):
        ...
    
    def check(self, **kwargs): # -> list[Unknown]:
        ...
    
    def db_type(self, connection): # -> None:
        ...
    
    def contribute_to_class(self, cls, name, private_only=..., **kwargs): # -> None:
        ...
    
    def deconstruct(self): # -> tuple[Unknown | None, str, list[Unknown], dict[Unknown, Unknown]]:
        ...
    
    def get_forward_related_filter(self, obj): # -> dict[str, Any]:
        """
        Return the keyword arguments that when supplied to
        self.model.object.filter(), would select all instances related through
        this field to the remote obj. This is used to build the querysets
        returned by related descriptors. obj is an instance of
        self.related_field.model.
        """
        ...
    
    def get_reverse_related_filter(self, obj): # -> Q:
        """
        Complement to get_forward_related_filter(). Return the keyword
        arguments that when passed to self.related_field.model.object.filter()
        select all instances of self.related_field.model related through
        this field to obj. obj is an instance of self.model.
        """
        ...
    
    @property
    def swappable_setting(self): # -> None:
        """
        Get the setting that this is powered from for swapping, or None
        if it's not swapped in / marked with swappable=False.
        """
        ...
    
    def set_attributes_from_rel(self): # -> None:
        ...
    
    def do_related_class(self, other, cls): # -> None:
        ...
    
    def get_limit_choices_to(self):
        """
        Return ``limit_choices_to`` for this model field.

        If it is a callable, it will be invoked and the result will be
        returned.
        """
        ...
    
    def formfield(self, **kwargs): # -> CharField | TypedChoiceField:
        """
        Pass ``limit_choices_to`` to the field being constructed.

        Only passes it if there is a type that supports related fields.
        This is a similar strategy used to pass the ``queryset`` to the field
        being constructed.
        """
        ...
    
    def related_query_name(self):
        """
        Define the name that can be used to identify this related object in a
        table-spanning query.
        """
        ...
    
    @property
    def target_field(self):
        """
        When filtering against this relation, return the field on the remote
        model against which the filtering should happen.
        """
        ...
    
    def get_cache_name(self):
        ...
    


class ForeignObject(RelatedField):
    """
    Abstraction of the ForeignKey relation to support multi-column relations.
    """
    many_to_many = ...
    many_to_one = ...
    one_to_many = ...
    one_to_one = ...
    requires_unique_target = ...
    related_accessor_class = ReverseManyToOneDescriptor
    forward_related_accessor_class = ForwardManyToOneDescriptor
    rel_class = ForeignObjectRel
    def __init__(self, to, on_delete, from_fields, to_fields, rel=..., related_name=..., related_query_name=..., limit_choices_to=..., parent_link=..., swappable=..., **kwargs) -> None:
        ...
    
    def __copy__(self): # -> Empty:
        ...
    
    def check(self, **kwargs): # -> list[Unknown]:
        ...
    
    def deconstruct(self): # -> tuple[Unknown | None, str, list[Unknown], dict[Unknown, Unknown]]:
        ...
    
    def resolve_related_fields(self): # -> list[Unknown]:
        ...
    
    @cached_property
    def related_fields(self): # -> list[Unknown]:
        ...
    
    @cached_property
    def reverse_related_fields(self): # -> list[tuple[Unknown, Unknown]]:
        ...
    
    @cached_property
    def local_related_fields(self): # -> tuple[Unknown, ...]:
        ...
    
    @cached_property
    def foreign_related_fields(self): # -> tuple[Unknown, ...]:
        ...
    
    def get_local_related_value(self, instance): # -> tuple[Unknown, ...]:
        ...
    
    def get_foreign_related_value(self, instance): # -> tuple[Unknown, ...]:
        ...
    
    @staticmethod
    def get_instance_value_for_fields(instance, fields): # -> tuple[Unknown, ...]:
        ...
    
    def get_attname_column(self): # -> tuple[Unknown | None, None]:
        ...
    
    def get_joining_columns(self, reverse_join=...): # -> tuple[tuple[Unknown, Unknown], ...]:
        ...
    
    def get_reverse_joining_columns(self): # -> tuple[tuple[Unknown, Unknown], ...]:
        ...
    
    def get_extra_descriptor_filter(self, instance): # -> dict[Unknown, Unknown]:
        """
        Return an extra filter condition for related object fetching when
        user does 'instance.fieldname', that is the extra filter is used in
        the descriptor of the field.

        The filter should be either a dict usable in .filter(**kwargs) call or
        a Q-object. The condition will be ANDed together with the relation's
        joining columns.

        A parallel method is get_extra_restriction() which is used in
        JOIN and subquery conditions.
        """
        ...
    
    def get_extra_restriction(self, alias, related_alias): # -> None:
        """
        Return a pair condition used for joining and subquery pushdown. The
        condition is something that responds to as_sql(compiler, connection)
        method.

        Note that currently referring both the 'alias' and 'related_alias'
        will not work in some conditions, like subquery pushdown.

        A parallel method is get_extra_descriptor_filter() which is used in
        instance.fieldname related object fetching.
        """
        ...
    
    def get_path_info(self, filtered_relation=...): # -> list[PathInfo]:
        """Get path from this field to the related model."""
        ...
    
    @cached_property
    def path_infos(self): # -> list[PathInfo]:
        ...
    
    def get_reverse_path_info(self, filtered_relation=...): # -> list[PathInfo]:
        """Get path from the related model to this field's model."""
        ...
    
    @cached_property
    def reverse_path_infos(self): # -> list[PathInfo]:
        ...
    
    @classmethod
    @functools.lru_cache(maxsize=None)
    def get_lookups(cls): # -> dict[Unknown, Unknown]:
        ...
    
    def contribute_to_class(self, cls, name, private_only=..., **kwargs): # -> None:
        ...
    
    def contribute_to_related_class(self, cls, related): # -> None:
        ...
    


class ForeignKey(ForeignObject):
    """
    Provide a many-to-one relation by adding a column to the local model
    to hold the remote value.

    By default ForeignKey will target the pk of the remote model but this
    behavior can be changed by using the ``to_field`` argument.
    """
    descriptor_class = ForeignKeyDeferredAttribute
    many_to_many = ...
    many_to_one = ...
    one_to_many = ...
    one_to_one = ...
    rel_class = ManyToOneRel
    empty_strings_allowed = ...
    default_error_messages = ...
    description = ...
    def __init__(self, to, on_delete, related_name=..., related_query_name=..., limit_choices_to=..., parent_link=..., to_field=..., db_constraint=..., **kwargs) -> None:
        ...
    
    def __class_getitem__(cls, *args, **kwargs): # -> Type[Self@ForeignKey]:
        ...
    
    def check(self, **kwargs): # -> list[Unknown]:
        ...
    
    def deconstruct(self): # -> tuple[Unknown | None, str, list[Unknown], dict[Unknown, Unknown]]:
        ...
    
    def to_python(self, value):
        ...
    
    @property
    def target_field(self):
        ...
    
    def get_reverse_path_info(self, filtered_relation=...): # -> list[PathInfo]:
        """Get path from the related model to this field's model."""
        ...
    
    def validate(self, value, model_instance): # -> None:
        ...
    
    def resolve_related_fields(self): # -> list[Unknown]:
        ...
    
    def get_attname(self):
        ...
    
    def get_attname_column(self): # -> tuple[Unknown, Unknown]:
        ...
    
    def get_default(self): # -> Any:
        """Return the to_field if the default value is an object."""
        ...
    
    def get_db_prep_save(self, value, connection): # -> None:
        ...
    
    def get_db_prep_value(self, value, connection, prepared=...):
        ...
    
    def get_prep_value(self, value):
        ...
    
    def contribute_to_related_class(self, cls, related): # -> None:
        ...
    
    def formfield(self, *, using=..., **kwargs): # -> CharField | TypedChoiceField:
        ...
    
    def db_check(self, connection): # -> None:
        ...
    
    def db_type(self, connection):
        ...
    
    def db_parameters(self, connection): # -> dict[str, Unknown]:
        ...
    
    def convert_empty_strings(self, value, expression, connection): # -> None:
        ...
    
    def get_db_converters(self, connection): # -> list[Unknown]:
        ...
    
    def get_col(self, alias, output_field=...): # -> cached_property | Col:
        ...
    


class OneToOneField(ForeignKey):
    """
    A OneToOneField is essentially the same as a ForeignKey, with the exception
    that it always carries a "unique" constraint with it and the reverse
    relation always returns the object pointed to (since there will only ever
    be one), rather than returning a list.
    """
    many_to_many = ...
    many_to_one = ...
    one_to_many = ...
    one_to_one = ...
    related_accessor_class = ReverseOneToOneDescriptor
    forward_related_accessor_class = ForwardOneToOneDescriptor
    rel_class = OneToOneRel
    description = ...
    def __init__(self, to, on_delete, to_field=..., **kwargs) -> None:
        ...
    
    def deconstruct(self): # -> tuple[Unknown | None, str, list[Unknown], dict[Unknown, Unknown]]:
        ...
    
    def formfield(self, **kwargs): # -> CharField | TypedChoiceField | None:
        ...
    
    def save_form_data(self, instance, data): # -> None:
        ...
    


def create_many_to_many_intermediary_model(field, klass): # -> Any:
    ...

class ManyToManyField(RelatedField):
    """
    Provide a many-to-many relation by using an intermediary model that
    holds two ForeignKey fields pointed at the two sides of the relation.

    Unless a ``through`` model was provided, ManyToManyField will use the
    create_many_to_many_intermediary_model factory to automatically generate
    the intermediary model.
    """
    many_to_many = ...
    many_to_one = ...
    one_to_many = ...
    one_to_one = ...
    rel_class = ManyToManyRel
    description = ...
    def __init__(self, to, related_name=..., related_query_name=..., limit_choices_to=..., symmetrical=..., through=..., through_fields=..., db_constraint=..., db_table=..., swappable=..., **kwargs) -> None:
        ...
    
    def check(self, **kwargs): # -> list[Unknown]:
        ...
    
    def deconstruct(self): # -> tuple[Unknown | None, str, list[Unknown], dict[Unknown, Unknown]]:
        ...
    
    def get_path_info(self, filtered_relation=...): # -> list[Unknown]:
        ...
    
    @cached_property
    def path_infos(self): # -> list[Unknown]:
        ...
    
    def get_reverse_path_info(self, filtered_relation=...): # -> list[Unknown]:
        ...
    
    @cached_property
    def reverse_path_infos(self): # -> list[Unknown]:
        ...
    
    def contribute_to_class(self, cls, name, **kwargs): # -> None:
        ...
    
    def contribute_to_related_class(self, cls, related): # -> None:
        ...
    
    def set_attributes_from_rel(self): # -> None:
        ...
    
    def value_from_object(self, obj): # -> list[Any]:
        ...
    
    def save_form_data(self, instance, data): # -> None:
        ...
    
    def formfield(self, *, using=..., **kwargs): # -> CharField | TypedChoiceField:
        ...
    
    def db_check(self, connection): # -> None:
        ...
    
    def db_type(self, connection): # -> None:
        ...
    
    def db_parameters(self, connection): # -> dict[str, None]:
        ...
    


