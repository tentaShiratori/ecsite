"""
This type stub file was generated by pyright.
"""

from django.db.models import lookups
from django.db.models.lookups import PostgresOperatorLookup, Transform
from . import Field
from .mixins import CheckFieldDefaultMixin

__all__ = ["JSONField"]
class JSONField(CheckFieldDefaultMixin, Field):
    empty_strings_allowed = ...
    description = ...
    default_error_messages = ...
    _default_hint = ...
    def __init__(self, verbose_name=..., name=..., encoder=..., decoder=..., **kwargs) -> None:
        ...
    
    def check(self, **kwargs):
        ...
    
    def deconstruct(self): # -> tuple[Unknown | None, str, list[Unknown], dict[Unknown, Unknown]]:
        ...
    
    def from_db_value(self, value, expression, connection): # -> Any | str:
        ...
    
    def get_internal_type(self): # -> Literal['JSONField']:
        ...
    
    def get_prep_value(self, value): # -> str:
        ...
    
    def get_transform(self, name): # -> Type[Transform] | KeyTransformFactory:
        ...
    
    def validate(self, value, model_instance): # -> None:
        ...
    
    def value_to_string(self, obj): # -> Any:
        ...
    
    def formfield(self, **kwargs): # -> CharField | TypedChoiceField:
        ...
    


def compile_json_path(key_transforms, include_root=...): # -> str:
    ...

class DataContains(PostgresOperatorLookup):
    lookup_name = ...
    postgres_operator = ...
    def as_sql(self, compiler, connection): # -> tuple[str, tuple[Unknown, ...]]:
        ...
    


class ContainedBy(PostgresOperatorLookup):
    lookup_name = ...
    postgres_operator = ...
    def as_sql(self, compiler, connection): # -> tuple[str, tuple[Value | Unknown, ...]]:
        ...
    


class HasKeyLookup(PostgresOperatorLookup):
    logical_operator = ...
    def compile_json_path_final_key(self, key_transform): # -> str:
        ...
    
    def as_sql(self, compiler, connection, template=...): # -> tuple[Unknown, tuple[Unknown, ...]]:
        ...
    
    def as_mysql(self, compiler, connection): # -> tuple[Unknown | str, tuple[Unknown, ...]]:
        ...
    
    def as_oracle(self, compiler, connection): # -> tuple[Unknown | str, list[Unknown]]:
        ...
    
    def as_postgresql(self, compiler, connection): # -> tuple[str, tuple[Unknown, ...]]:
        ...
    
    def as_sqlite(self, compiler, connection): # -> tuple[Unknown | str, tuple[Unknown, ...]]:
        ...
    


class HasKey(HasKeyLookup):
    lookup_name = ...
    postgres_operator = ...
    prepare_rhs = ...


class HasKeys(HasKeyLookup):
    lookup_name = ...
    postgres_operator = ...
    logical_operator = ...
    def get_prep_lookup(self): # -> list[str]:
        ...
    


class HasAnyKeys(HasKeys):
    lookup_name = ...
    postgres_operator = ...
    logical_operator = ...


class HasKeyOrArrayIndex(HasKey):
    def compile_json_path_final_key(self, key_transform): # -> str:
        ...
    


class CaseInsensitiveMixin:
    """
    Mixin to allow case-insensitive comparison of JSON values on MySQL.
    MySQL handles strings used in JSON context using the utf8mb4_bin collation.
    Because utf8mb4_bin is a binary collation, comparison of JSON values is
    case-sensitive.
    """
    def process_lhs(self, compiler, connection): # -> tuple[Unknown, Unknown]:
        ...
    
    def process_rhs(self, compiler, connection): # -> tuple[Unknown, Unknown]:
        ...
    


class JSONExact(lookups.Exact):
    can_use_none_as_rhs = ...
    def process_rhs(self, compiler, connection): # -> tuple[Unknown | str, list[str] | Unknown | list[Value | Unknown]]:
        ...
    


class JSONIContains(CaseInsensitiveMixin, lookups.IContains):
    ...


class KeyTransform(Transform):
    postgres_operator = ...
    postgres_nested_operator = ...
    def __init__(self, key_name, *args, **kwargs) -> None:
        ...
    
    def preprocess_lhs(self, compiler, connection): # -> tuple[Unknown, Unknown, list[str]]:
        ...
    
    def as_mysql(self, compiler, connection): # -> tuple[Unknown, tuple[Unknown, ...]]:
        ...
    
    def as_oracle(self, compiler, connection): # -> tuple[str, tuple[Unknown, ...]]:
        ...
    
    def as_postgresql(self, compiler, connection): # -> tuple[str, tuple[Unknown, ...]]:
        ...
    
    def as_sqlite(self, compiler, connection): # -> tuple[str, tuple[Unknown, ...]]:
        ...
    


class KeyTextTransform(KeyTransform):
    postgres_operator = ...
    postgres_nested_operator = ...


class KeyTransformTextLookupMixin:
    """
    Mixin for combining with a lookup expecting a text lhs from a JSONField
    key lookup. On PostgreSQL, make use of the ->> operator instead of casting
    key values to text and performing the lookup on the resulting
    representation.
    """
    def __init__(self, key_transform, *args, **kwargs) -> None:
        ...
    


class KeyTransformIsNull(lookups.IsNull):
    def as_oracle(self, compiler, connection): # -> tuple[Unknown | str, list[Unknown]] | tuple[str, tuple[Unknown, ...]]:
        ...
    
    def as_sqlite(self, compiler, connection): # -> tuple[Unknown | str, tuple[Unknown, ...]]:
        ...
    


class KeyTransformIn(lookups.In):
    def resolve_expression_parameter(self, compiler, connection, sql, param): # -> tuple[LiteralString | Unknown | Literal['JSON_EXTRACT(%s, \'$\')'], Unknown | list[Unknown]]:
        ...
    


class KeyTransformExact(JSONExact):
    def process_rhs(self, compiler, connection): # -> tuple[Unknown, Unknown] | tuple[Literal['%s'], list[Value | Unknown]] | tuple[Unknown | str, list[str] | Unknown | list[Value | Unknown]]:
        ...
    
    def as_oracle(self, compiler, connection): # -> tuple[str, tuple[Unknown, ...]] | tuple[Unknown, list[Unknown]] | tuple[LiteralString, list[Unknown]]:
        ...
    


class KeyTransformIExact(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IExact):
    ...


class KeyTransformIContains(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IContains):
    ...


class KeyTransformStartsWith(KeyTransformTextLookupMixin, lookups.StartsWith):
    ...


class KeyTransformIStartsWith(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IStartsWith):
    ...


class KeyTransformEndsWith(KeyTransformTextLookupMixin, lookups.EndsWith):
    ...


class KeyTransformIEndsWith(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IEndsWith):
    ...


class KeyTransformRegex(KeyTransformTextLookupMixin, lookups.Regex):
    ...


class KeyTransformIRegex(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IRegex):
    ...


class KeyTransformNumericLookupMixin:
    def process_rhs(self, compiler, connection): # -> tuple[Unknown, list[Any] | Unknown]:
        ...
    


class KeyTransformLt(KeyTransformNumericLookupMixin, lookups.LessThan):
    ...


class KeyTransformLte(KeyTransformNumericLookupMixin, lookups.LessThanOrEqual):
    ...


class KeyTransformGt(KeyTransformNumericLookupMixin, lookups.GreaterThan):
    ...


class KeyTransformGte(KeyTransformNumericLookupMixin, lookups.GreaterThanOrEqual):
    ...


class KeyTransformFactory:
    def __init__(self, key_name) -> None:
        ...
    
    def __call__(self, *args, **kwargs): # -> KeyTransform:
        ...
    


