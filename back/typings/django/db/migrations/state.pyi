"""
This type stub file was generated by pyright.
"""

from contextlib import contextmanager
from django.apps import AppConfig
from django.apps.registry import Apps
from django.utils.functional import cached_property

def get_related_models_tuples(model): # -> set[tuple[Unknown, Unknown]]:
    """
    Return a list of typical (app_label, model_name) tuples for all related
    models for the given model.
    """
    ...

def get_related_models_recursive(model): # -> set[Unknown]:
    """
    Return all models that have a direct or indirect relationship
    to the given model.

    Relationships are either defined by explicit relational fields, like
    ForeignKey, ManyToManyField or OneToOneField, or by inheriting from another
    model (a superclass is related to its subclasses, but not vice versa). Note,
    however, that a model inheriting from a concrete model is also related to
    its superclass through the implicit *_ptr OneToOneField on the subclass.
    """
    ...

class ProjectState:
    """
    Represent the entire project's overall state. This is the item that is
    passed around - do it here rather than at the app level so that cross-app
    FKs/etc. resolve properly.
    """
    def __init__(self, models=..., real_apps=...) -> None:
        ...
    
    @property
    def relations(self): # -> defaultdict[Unknown, defaultdict[Unknown, Unknown]] | None:
        ...
    
    def add_model(self, model_state): # -> None:
        ...
    
    def remove_model(self, app_label, model_name): # -> None:
        ...
    
    def rename_model(self, app_label, old_name, new_name): # -> None:
        ...
    
    def alter_model_options(self, app_label, model_name, options, option_keys=...): # -> None:
        ...
    
    def remove_model_options(self, app_label, model_name, option_name, value_to_remove): # -> None:
        ...
    
    def alter_model_managers(self, app_label, model_name, managers): # -> None:
        ...
    
    def add_index(self, app_label, model_name, index): # -> None:
        ...
    
    def remove_index(self, app_label, model_name, index_name): # -> None:
        ...
    
    def rename_index(self, app_label, model_name, old_index_name, new_index_name): # -> None:
        ...
    
    def add_constraint(self, app_label, model_name, constraint): # -> None:
        ...
    
    def remove_constraint(self, app_label, model_name, constraint_name): # -> None:
        ...
    
    def add_field(self, app_label, model_name, name, field, preserve_default): # -> None:
        ...
    
    def remove_field(self, app_label, model_name, name): # -> None:
        ...
    
    def alter_field(self, app_label, model_name, name, field, preserve_default): # -> None:
        ...
    
    def rename_field(self, app_label, model_name, old_name, new_name): # -> None:
        ...
    
    def reload_model(self, app_label, model_name, delay=...): # -> None:
        ...
    
    def reload_models(self, models, delay=...): # -> None:
        ...
    
    def update_model_field_relation(self, model, model_key, field_name, field, concretes): # -> None:
        ...
    
    def resolve_model_field_relations(self, model_key, field_name, field, concretes=...): # -> None:
        ...
    
    def resolve_model_relations(self, model_key, concretes=...): # -> None:
        ...
    
    def resolve_fields_and_relations(self): # -> None:
        ...
    
    def get_concrete_model_key(self, model):
        ...
    
    def clone(self): # -> ProjectState:
        """Return an exact copy of this ProjectState."""
        ...
    
    def clear_delayed_apps_cache(self): # -> None:
        ...
    
    @cached_property
    def apps(self): # -> StateApps:
        ...
    
    @classmethod
    def from_apps(cls, apps): # -> Self@ProjectState:
        """Take an Apps and return a ProjectState matching it."""
        ...
    
    def __eq__(self, other) -> bool:
        ...
    


class AppConfigStub(AppConfig):
    """Stub of an AppConfig. Only provides a label and a dict of models."""
    def __init__(self, label) -> None:
        ...
    
    def import_models(self): # -> None:
        ...
    


class StateApps(Apps):
    """
    Subclass of the global Apps registry class to better handle dynamic model
    additions and removals.
    """
    def __init__(self, real_apps, models, ignore_swappable=...) -> None:
        ...
    
    @contextmanager
    def bulk_update(self): # -> Generator[None, None, None]:
        ...
    
    def render_multiple(self, model_states): # -> None:
        ...
    
    def clone(self): # -> StateApps:
        """Return a clone of this registry."""
        ...
    
    def register_model(self, app_label, model): # -> None:
        ...
    
    def unregister_model(self, app_label, model_name): # -> None:
        ...
    


class ModelState:
    """
    Represent a Django Model. Don't use the actual Model class as it's not
    designed to have its options changed - instead, mutate this one and then
    render it into a Model as required.

    Note that while you are allowed to mutate .fields, you are not allowed
    to mutate the Field instances inside there themselves - you must instead
    assign new ones, as these are not detached during a clone.
    """
    def __init__(self, app_label, name, fields, options=..., bases=..., managers=...) -> None:
        ...
    
    @cached_property
    def name_lower(self):
        ...
    
    def get_field(self, field_name):
        ...
    
    @classmethod
    def from_model(cls, model, exclude_rels=...):
        """Given a model, return a ModelState representing it."""
        ...
    
    def construct_managers(self): # -> Generator[tuple[Any, Any], None, None]:
        """Deep-clone the managers using deconstruction."""
        ...
    
    def clone(self): # -> ModelState:
        """Return an exact copy of this ModelState."""
        ...
    
    def render(self, apps): # -> Any:
        """Create a Model object from our current state into the given apps."""
        ...
    
    def get_index_by_name(self, name): # -> Any:
        ...
    
    def get_constraint_by_name(self, name): # -> Any:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    


